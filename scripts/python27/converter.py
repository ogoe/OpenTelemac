#!/usr/bin/env python
"""@author Yoann Audouin
"""
"""@note ... this work is based on a collaborative effort between
  .________.                                                          ,--.
  |        |                                                      .  (  (
  |,-.    /   HR Wallingford                EDF - LNHE           / \_ \_/ .--.
  /   \  /    Howbery Park,                 6, quai Watier       \   )   /_   )
   ,.  `'     Wallingford, Oxfordshire      78401 Cedex           `-'_  __ `--
  /  \   /    OX10 8BA, United Kingdom      Chatou, France        __/ \ \ `.
 /    `-'|    www.hrwallingford.com         innovation.edf.com   |    )  )  )
!________!                                                        `--'   `--
"""
"""@history 15/02/2013 -- Sebastien E. Bourban
         Adding the file in pytel
"""
"""@brief Run a converions of mesh files using stbtel
"""
# _____          ___________________________________________________
# ____/ Imports /__________________________________________________/
#
# ~~> dependencies towards standard python
import sys
import os
import subprocess as sp
from optparse import OptionParser
try:
    from MEDLoader import *
    ML_AVAIL = True
except ImportError:
    print "MEDLaoder unavailable boundary elements will "\
          "not be added when converting to MED"
    print "Install MEDLoader or run inside a salome shell"
    ML_AVAIL = False

# _____             ________________________________________________
# ____/ MAIN CALL  /_______________________________________________/
#

__author__="Yoann Audouin"
__date__ ="$21-Sep-2012 16:51:09$"


casCanvas = \
"""
/
/ CONVERSION OF MESH FILE USING STBTEL
/
CONVERTER = YES
DEBUG = {debug}
/
/ INPUT FILE INFORMATION
/
INPUT FILE FORMAT : '{inputFormat}'
INPUT FILE : '{inputFile}'
BOUNDARY CONDITION IN SERAFIN FORMAT : {srfBnd}
{inAdditionalFile}
/ Translation information
TRANSLATION : {translate}
X TRANSLATION : {dx}
Y TRANSLATION : {dy}
/
/ OUTPUT FILE INFORMATION
/
OUTPUT FILE FORMAT : '{outputFormat}'
OUTPUT FILE : '{outputFile}'
{outAdditionalFile}
"""

casRefinementCanvas = \
"""
/
/ REFINEMENT OF MESH FILE USING STBTEL
/
/
/ INPUT FILE INFORMATION
/
UNIVERSAL FILE : '{inputFile}'
BOUNDARY UNIVERSAL FILE : '{inputBndFile}'
/
MESH GENERATOR : 'SELAFIN'
CUTTING ELEMENTS IN FOUR : YES
/
/ OUTPUT FILE INFORMATION
/
GEOMETRY FILE FOR TELEMAC : '{outputFile}'
BOUNDARY CONDITIONS FILE : '{outputBndFile}'
"""

def build_refine_cas(inputFile,boundaryFile,outputName):
   """
      Create the cas file for a refinement job
      @param inputFile Name of the file to refine
      @param boundaryFile Name of the boundary file associated with the file to refine
      @param ouputName Basename of the ouput
   """
   return casRefinementCanvas.format(inputFile=inputFile,
                                    inputBndFile=boundaryFile,
                                    outputFile=outputName+".slf",
                                    outputBndFile=outputFile+".cli")

def add_bnd(inputFile):
   """
      Add the boundary element and the groups in a med file generated by the
      converter in Stbtel
      @param inputFile Name of the file in which to add the boundaries
   """

   # Open the file
   meshFile2D = MEDFileUMesh(inputFile,"MESH")

   # Change coordiantes names TODO: Change that in the converter
   coords = meshFile2D.getCoords()
   coords.setInfoOnComponents(["X [m]","Y [m]"])

   # Extract 2D mesh
   m2D = meshFile2D.getMeshAtLevel(0)

   # Compute boudanry elements
   m1D = m2D.computeSkin()

   # Order cells for med format
   m1D.sortCellsInMEDFileFrmt()

   nSegment = m1D.getNumberOfCells()
   # Create groups
   grps = []
   for groupName in meshFile2D.getGroupsNames():
      cells = []
      nodeInGroup = meshFile2D.getNodeGroupArr(groupName)
      for cell in range(nSegment):
         cell1,cell2 = m1D.getNodeIdsOfCell(cell)
         if groupName != 'CONLIM_222':
            if cell1 in nodeInGroup and cell2 in nodeInGroup:
               cells.append(cell)
         else:
            if cell1 in nodeInGroup or cell2 in nodeInGroup:
               cells.append(cell)
      grp = DataArrayInt(cells)
      grp.setName(groupName)
      grps.append(grp)

   # Add Boundary elements to the file
   meshFile2D.setMeshAtLevel(-1,m1D)

   # Add the groups to the file
   meshFile2D.setGroupsAtLevel(-1, grps)

   # Write the new information
   meshFile2D.write(inputFile,0)

def build_cas(options,extens,inputFormat,inputFile,outputFormat,outputFile):
   """
   Build the steering file for stbtel
   """
   # Building canvas for steering file
   debug = 'YES' if options.debug else 'NO'
   srfBnd = 'YES' if options.srfBnd else 'NO'
   translate = 'YES' if (options.dx <> '0.D0' or options.dy <> '0.D0') else 'NO'
   # Additional files
   ## input files
   inAdditionalFile = ''
   if options.boundaryFile:
      inAdditionalFile += "BOUNDARY FILE : '%s' \n" % (options.boundaryFile + extens)
   if options.logFile:
      inAdditionalFile += "LOG FILE : '%s' \n" % (options.logFile + extens)
   ## Output files
   outAdditionalFile = ''
   if outputFormat == "SERAFIN":
      outAdditionalFile += "OUTPUT BOUNDARY FILE : '%s'\n" % (outputFile[:-3] + 'cli' + extens)
   # If th output is in UNV format add the name of the log file
   if outputFormat == "UNV":
      outAdditionalFile += "OUTPUT LOG FILE : '%s'\n" % (outputFile[:-3]+'log'+extens)

   return casCanvas.format(
             debug=debug,
             inputFormat=inputFormat,
             inputFile=inputFile+extens,
             srfBnd=srfBnd,
             inAdditionalFile=inAdditionalFile,
             outputFormat=outputFormat,
             outputFile=outputFile+extens,
             outAdditionalFile=outAdditionalFile,
             translate=translate,
             dx=options.dx,
             dy=options.dy
             )

if __name__ == "__main__":

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# ~~ Reads options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # define the different file extension and the format name associated
   formats = {"slf":"SERAFIN",
              "srf":"SERAFIN",
              "sel":"SERAFIN",
              "med":"MED",
              "vtk":"VTK",
              "unv":"UNV",
              "cgns":"CGNS"}
   # Define a parser for the program options
   parser = OptionParser("Usage: %prog input-file-name -o output-file-name [options]\n"+
         "Example: converter.py coarse.slf -b coarse.cli -o coarse.med --debug\n"+
         "Where coarse.slf is the mesh in SERAFIN fornat,\n"+
         "      coarse.cli is the boundary conditions file and\n"+
         "      coarse.med the converted mesh in MED format.\n"+
         "Example: converter.py --refine coarse.slf -b coarse.cli -o coarsex4")
   # output name option
   parser.add_option("-o","--output-file",
             type="string",
             dest="outputFile",
             default="output.med",
             help="name of the output file also defines the output format")
   # output fomrat
   parser.add_option("","--input-format",
             type="string",
             dest="inputFormat",
             default="",
             help="name of the input format, overwrites input detected by extension")
   # output fomrat
   parser.add_option("","--output-format",
             type="string",
             dest="outputFormat",
             default="",
             help="name of the output format, overwrites output detected by extension")
   # the boundary file option
   parser.add_option("", "--output-boundary-file",
             type="string",
             dest="outBoundaryFile",
             default="",
             help="name of the output boundary file")
   # the boundary file option
   parser.add_option("-b","--boundary-file",
             type="string",
             dest="boundaryFile",
             default="",
             help="name of the boundary file")
   # the log file option
   parser.add_option("-l","--log-file",
             type="string",
             dest="logFile",
             default="",
             help="name of the log file")
   # option for converting distributed mesh
   parser.add_option("-n","--ndomains",
             type="int",
             dest="ndomains",
             default=1,
             help="number of sub-domains of the distributed mesh")
   # Option to tell stbtel to read the boundary conidtion from the boundary file
   parser.add_option("","--srf-bnd",
             action="store_true",
             dest="srfBnd",
             default=False,
             help="tell stbtel to read the boundary conidtion from the boundary file")
   # the silent option define if display stbtel informations
   parser.add_option("-s","--silent",
             action="store_true",
             dest="silent",
             default=False,
             help="disable stbtel output informations")
   # the debug mode option
   parser.add_option("","--debug",
             action="store_true",
             dest="debug",
             default=False,
             help="Enable debug mode which displays more informations during run time")
   # option for Translation on x
   parser.add_option("","--dx",
             type="string",
             dest="dx",
             default='0.D0',
             help="Value to add to the X coordinates")
   # option for Translation on y
   parser.add_option("","--dy",
             type="string",
             dest="dy",
             default='0.D0',
             help="Value to add to the y coordinates")
   # root directory
   parser.add_option("-r", "--rootdir",
                     type = "string",
                     dest = "rootDir",
                     default = None,
                     help="specify the root, default is taken from config file")
   # the debug mode option
   parser.add_option("","--refine",
             action="store_true",
             dest="refine",
             default=False,
             help="Run a refine job instead of a conversion the refinement will "\
                  "split each triangle in four. "\
                  "The option -b is mandatory. "\
                  "This only works for SERAFIN format.")

   # reading the options
   options, args = parser.parse_args()

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# ~~~~ Identifying input and output informations ~~~~~~~~~~~~~~~~~~~
   if len(args) < 1:
      parser.print_help()
      parser.error("Missing input file\n")
   # Getting input and output file names
   inputFile = args[0]
   outputFile = options.outputFile
   if not options.inputFormat:
      # Finding the input format by checking the extension
      i = inputFile.rfind('.')
      inputExtension = inputFile[i+1:]
      if not inputFile.endswith(tuple(formats.keys())):
         parser.error("The input file extension is unknown\n Known are : %r"
                      % formats)
      else:
         inputFormat = formats[inputExtension]
   else:
      inputFormat = options.inputFormat
   # only checking output format if in convertion mode
   if not options.refine:
      # If no format was given as option try to indentify format from extension
      if not options.outputFormat:
         # Finding the output format
         i = outputFile.rfind('.')
         outputExtension = outputFile[i+1:]
         if not outputFile.endswith(tuple(formats.keys())):
            parser.error("The output file extension is unknown\n Known are : %r"
                         % formats)
         else:
            outputFormat = formats[outputExtension]
      else:
         outputFormat = options.outputFormat
   else:
      outputFormat = 'SERAFIN'

   # Loop on the number of domains
   ndomains = options.ndomains
   for idom in range(0,ndomains):
      # build the extension added to each file of the distributed mesh by partel
      if ndomains == 1:
         # Nothing if we are dealling with a non-distributed mesh
         extens=''
      else:
         # the string of format 00000-00000
         extens=str(ndomains-1).zfill(5)+'-'+str(idom).zfill(5)

      # Treatment in case we are doing a refinement
      if options.refine:
         if inputFormat != 'SERAFIN':
            parser.error("Refinement is only available in Serafin format")
         elif options.boundaryFile == ' ':
            parser.error("Missing boundary file for refinement")
         else:
            cas = build_refine_cas(inputFile,options.boundaryFile,outputFile)
      else:
         cas = build_cas(options, extens, inputFormat, inputFile,
                         outputFormat, outputFile)
      # Writting the steering file
      casName = 'stb'+extens+".cas"
      with open(casName,"w") as fobj:
         fobj.write(cas)
      # Running stbtel
      path_stbtel = "stbtel.py"
      if options.rootDir is not None:
        path_stbtel = os.path.join(options.rootDir, "scripts", "python27", path_stbtel)
      stbtel_args = [path_stbtel, casName]
      if options.rootDir is not None:
         stbtel_args += ["-r", options.rootDir]
      print "Calling:", " ".join(stbtel_args)
      rc = sp.call(stbtel_args)

      if rc != 0:
         sys.exit(rc)
      else:
         # Remove the case file
         os.remove(casName)
      # In case of a conversion srf to med adding bnd elements and we have boundaries
      if(inputFormat == 'SERAFIN' and outputFormat == 'MED' \
         and options.boundaryFile and ML_AVAIL):
          print "-> Adding boundary elements"
          add_bnd(outputFile)



   print '\n\n'+'~'*72
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# ~~~~ Jenkins' success message ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   print '\n\nMy work is done\n\n'

   sys.exit(0)
