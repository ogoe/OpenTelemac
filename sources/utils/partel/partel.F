!                    *****************
                     SUBROUTINE PARTEL
!                    *****************
     & (NAMEINP, NAMECLI, NPARTS, PMETHOD, FFORMAT,
     &  NAMESEC, NAMEZFI, NAMESEU)
!
!
!***********************************************************************
! PARALLEL   V7P2
!***********************************************************************
!
!brief    PREPROCESSING STEP BEFORE A PARALLEL COMPUTATION
!
!history   R. KOPMANN (BAW)
!+
!+
!+         FIRST  VERSION JANUARY-MARCH 2000
!
!history   JAJ
!+      12/12/2000
!+      SECOND VERSION PINXIT
!+     PARTITIONING OF GEOMETRY AND 2D RESULT FILES POSSIBLE

!history   JAJ
!+      22/02/2002
!+      THIRD VERSION
!+     ERRORS IN BC VALUES IN DECOMPOSED BC FILES REMOVED
!+     ERRONEOUS TREATMENT OF ISLANDS DEBUGGED
!
!history   J-M HERVOUET ; JAJ
!+      17/04/2002
!+     FOURTH VERSION
!+     PARTITIONING FOR 3D RESULT FILES DONE BY JMH
!+     INCLUDING BOTH PARTITIONING METHODS AND BEAUTIFYING BY JAJ
!
!history  J-M HERVOUET
!+     21/01/2003
!+     FIFTH VERSION
!+     CORRECTED A WRONG DIMENSION OF THE ARRAY CUT, AN ERROR
!+     OCCURING BY A LARGER NUMBER OF PROCESSORS
!
!history  J-M HERVOUET
!+       12/03/2003
!+      SEVENTH VERSION
!+      ALGORITHM CHANGED : A SEGMENT IS IN A SUBDOMAIN IF IT BELONGS
!+      TO AN ELEMENT IN THE SUBDOMAIN NOT IF THE 2 POINTS OF THE
!+      SEGMENT BELONG TO THE SUBDOMAIN.
!+       SPECIFIC ELEBD INCLUDED, ALL REFERENCE TO MPI OR BIEF REMOVED
!
!history  J-M HERVOUET
!+        01/09/2003
!+      EIGHTH VERSION
!+      UBOR AND VBOR INVERTED LINE 613 WHEN READING THE CLI FILE.
!+    OTHER MODIFICATIONS PERFORMED
!
!history  C. DENIS J-M HERVOUET (SINETICS & LNHE)
!+        22/06/2012
!+        V6P2
!+      Double precision SERAFIN now possible.
!
!history  Y. AUDOUIN (STFC & LNHE)
!+        25/06/2012
!+        V6P2
!+      Interface for latest release of METIS (>= Version 5)
!
!history  J-M HERVOUET (EDF LAB, LNHE)
!+        27/03/2014
!+        V7P0
!+    Arguments added to the call elebd.
!
!history Y AUDOUIN (LNHE)
!+       25/05/2015
!+       V7P0
!+       Modification to comply with the hermes module
!
!history C. COULET (ARTELIA)
!+       01/09/2016
!+       V7P2
!+       Modification to add the weir file management
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!| NAMEGEO        |<--| NAME OF THE GEOMETRY FILE
!| NAMECLI        |<--| NAME OF THE BOUNDARY CONDITIONS FILE
!| NPARTS         |<--| NUMBER OF PARTITIONS
!| PMETHOD        |<--| 1: FOR METIS 2: FOR SCOTCH
!| FFORMAT        |<--| FORMAT OF THE GEOMETRY FILE
!| NAMESEC        |<--| NAME OF THE SECTION FILE ' ' IF THERE ARE NONE
!| NAMEZFI        |<--| NAME OF THE FRICTION ZONE FILE ' ' IF THERE ARE NONE
!| NAMESEU        |<--| NAME OF THE WEIR FILE ' ' IF THERE ARE NONE
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      USE DECLARATIONS_PARTEL
      USE DECLARATIONS_SPECIAL
      USE BIEF, ONLY : NBMAXNSHARE, NCSIZE, NPTIR, CHAIN_TYPE,
     &                 READ_MESH_INFO, FRONT2
      USE INTERFACE_HERMES
!
      IMPLICIT NONE
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      CHARACTER(LEN=MAXLENHARD), INTENT(IN) :: NAMEINP
      CHARACTER(LEN=MAXLENHARD), INTENT(IN) :: NAMECLI
      INTEGER, INTENT(IN) :: NPARTS
      INTEGER, INTENT(IN) :: PMETHOD
      CHARACTER(LEN=8), INTENT(INOUT) :: FFORMAT
      CHARACTER(LEN=MAXLENHARD), INTENT(IN) :: NAMESEC
      CHARACTER(LEN=MAXLENHARD), INTENT(IN) :: NAMEZFI
      CHARACTER(LEN=MAXLENHARD), INTENT(IN) :: NAMESEU
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!
      INTEGER NVAR, NPLAN, NPTFR
      INTEGER NELEM, NPOIN, NDP, NELEM2, NPOIN2, NDP_BND
      INTEGER DIM_MESH
!
      INTEGER, ALLOCATABLE :: IKLES(:), IKLES_P(:)
      INTEGER, ALLOCATABLE :: IKLES3D(:),IKLES3D_P(:,:,:)
      INTEGER, ALLOCATABLE :: IRAND(:)
      INTEGER, ALLOCATABLE :: LIHBOR(:),LIUBOR(:)
      INTEGER, ALLOCATABLE :: LIVBOR(:),LITBOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: HBOR(:),UBOR(:),VBOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: CHBORD(:)
      DOUBLE PRECISION, ALLOCATABLE :: TBOR(:),ATBOR(:),BTBOR(:)
      INTEGER, ALLOCATABLE :: LIHBOR_P(:),LIUBOR_P(:)
      INTEGER, ALLOCATABLE :: LIVBOR_P(:),LITBOR_P(:)
      DOUBLE PRECISION, ALLOCATABLE :: HBOR_P(:),UBOR_P(:),VBOR_P(:)
      DOUBLE PRECISION, ALLOCATABLE :: CHBORD_P(:)
      DOUBLE PRECISION, ALLOCATABLE :: TBOR_P(:),ATBOR_P(:),BTBOR_P(:)
      INTEGER, ALLOCATABLE :: NBOR(:),IKLE_BND_P(:),IKLE_BND(:)
      INTEGER, ALLOCATABLE :: NPOIN_P(:), NELEM_P(:), NPTFR_P(:)
      INTEGER, ALLOCATABLE :: NPTIR_P(:)
      INTEGER, ALLOCATABLE :: NUMLIQ(:)
      INTEGER, ALLOCATABLE :: KNOLG(:,:), KNOGL(:,:)
      INTEGER, ALLOCATABLE :: ELELG(:,:)
      INTEGER, ALLOCATABLE :: CUT(:), CUT_P(:,:), SORT(:)
      INTEGER, ALLOCATABLE :: PART_P(:,:)
!
!     FOR DOUBLE PRECISION SERAFIN FORMAT
!
      DOUBLE PRECISION, ALLOCATABLE    :: F(:,:)
!
      DOUBLE PRECISION TIMES
!
      INTEGER :: NINP=10, NSCT=13
      INTEGER :: NOUT=17, NCLM=18
      INTEGER TIME(3),DATE(3), DATE_TMP(6)
!
      CHARACTER(LEN=80)  :: TITLE
      CHARACTER(LEN=32), ALLOCATABLE  :: VARIABLE(:)
      CHARACTER(LEN=MAXLENHARD)  :: NAMEOUT, NAMECLM
      CHARACTER(LEN=12)  :: FMT4
!
      INTEGER MAX_NELEM_P
      INTEGER  MAX_NPOIN_P,MAX_N_NEIGH
      INTEGER I, J, K, L , M, N, ISO, IDUM
      INTEGER ISEG, NTIMESTEP
!
      REAL XSEG, YSEG
      LOGICAL TIMECOUNT
!
! METISOLOGY
!
      INTEGER, ALLOCATABLE :: EPART(:), NPART(:)
!
! FOR CALLING FRONT2
!
      INTEGER, PARAMETER :: MAXFRO = 30
      INTEGER, ALLOCATABLE :: NACHB(:,:)
      INTEGER, ALLOCATABLE :: DEJAVU(:), KP1BOR(:,:)
      INTEGER :: NFRLIQ
!
! FOR CALLING BIEF MESH SUBROUTINES (TO BE OPTIMISED SOON):
!
      INTEGER, ALLOCATABLE :: IFABOR(:,:), IFANUM(:,:), NELBOR(:)
      INTEGER, ALLOCATABLE :: NULONE(:,:)
      INTEGER, ALLOCATABLE :: IKLE(:,:), IKLBOR(:,:), ISEGF(:)
      INTEGER, ALLOCATABLE :: IT1(:), IT2(:), IT3(:)
!
! TIME MEASURING
!
      INTEGER  TDEB, TFIN, TDEBP, TFINP, TEMPS, PARSEC
!     HERMES TEMPORARY ARRAYS
      DOUBLE PRECISION, ALLOCATABLE :: X(:), Y(:)
      DOUBLE PRECISION,ALLOCATABLE :: DATAVAL(:), DATAVAL_P(:)
      INTEGER, ALLOCATABLE :: KNOLG_P(:), IKLE_P(:), IKLE3D_P(:)
      INTEGER :: IERR, ITIME, IVAR
      CHARACTER(LEN=16), ALLOCATABLE :: VAR_NAME(:), VAR_UNIT(:)
      INTEGER NELEBD, NELEBD_P
      INTEGER TYP_ELEM, TYP_BND_ELEM
      LOGICAL FULLY_IN
      INTEGER :: ID
!
!----------------------------------------------------------------------
!
!JAJ NEW FOR PARALLEL CHARACTERISTICS ////
! HALO ELEMENTS: THESE ADJACENT TO THE INTERFACE EDGES HAVING
! NEIGHBOURS BEHIND A BOUNDARY
!
      ! THE ELEMENTAL GLOBAL->LOCAL NUMBERING TRANSLATION TABLE
      ! THIS IS ELEGL SAVED FROM ALL PARTITIONS FOR FURTHER USE
      INTEGER, ALLOCATABLE :: GELEGL(:,:)
!
      ! THE HALO ELEMENTS NEIGHBOURHOOD DESCRIPTION FOR A HALO CELL
      INTEGER, ALLOCATABLE :: IFAPAR(:,:,:)
!
      ! THE NUMBER OF HALO CELLS PRO PARTITION
      INTEGER, ALLOCATABLE :: NHALO(:)
!
!     WORK VARIABLES
!
      INTEGER IFALOC(3)
      LOGICAL FOUND
      INTEGER NDP_2D
      INTEGER EF,POSI
      INTEGER, ALLOCATABLE :: NBRE_EF(:),NBRE_EF_LOC(:),EF_I(:)
      INTEGER, ALLOCATABLE :: TAB_TMP(:),EF_II(:)
      LOGICAL HALO
      INTEGER NOEUD,NBRE_NOEUD_INTERNE
      INTEGER NBRE_EF_I
      LOGICAL INTERFCE
!
! #### FOR SECTIONS
!
      TYPE (CHAIN_TYPE), ALLOCATABLE :: CHAIN(:)
      INTEGER, PARAMETER :: NSEMAX=500 ! MAX NUMBER OF SEGMENTS IN A SECTION
      INTEGER, ALLOCATABLE :: LISTE(:,:), ANPBEG(:),ANPEND(:)
      INTEGER :: NSEC, IHOWSEC, ISEC, IELEM, IM(1), IN(1), NPBEG, NPEND
      INTEGER :: PT, I1,I2,I3, ARR,DEP, ILPREC,ILBEST,ELBEST,IGBEST
      DOUBLE PRECISION :: XA, YA, DISTB, DISTE, DMINB, DMINE
      DOUBLE PRECISION :: DIST1, DIST2, DIST3, DIST
      LOGICAL :: WITH_SECTIONS
!
! #### FOR ZONES
!
      INTEGER, ALLOCATABLE :: FRICTION(:)
      INTEGER :: NZFI,I_GLOB,VAL_ZFI
      LOGICAL :: WITH_ZONES
!
!     CD: FLAG FOR SERAFIN FORMAT (.TRUE. IF DOUBLE PRECISION)
!
!     PARTEL EXTENS
      CHARACTER(LEN=11) :: EXTENS
      EXTERNAL EXTENS
!
! #### FOR WEIRS
!
      INTEGER :: NSEU, NBSEU, OPSEU, JJ, PROC
      INTEGER, ALLOCATABLE :: NUM_SEU1(:,:), NUM_SEU2(:,:)
      INTEGER, ALLOCATABLE :: NUM_SEU1_P(:,:,:), NUM_SEU2_P(:,:,:)
      INTEGER, ALLOCATABLE :: SEU_P(:,:), CSEU_P(:,:), P_CSEU(:,:)
      INTEGER, ALLOCATABLE :: LRECV_P(:,:), NRECV_P(:)
      INTEGER, ALLOCATABLE :: LSEND_PP(:,:,:), LSEND_P(:,:), NSEND_P(:)
      INTEGER, ALLOCATABLE :: LIST_TMP(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: XSEU1(:), YSEU1(:), ZSEU1(:)
      DOUBLE PRECISION, ALLOCATABLE :: XSEU2(:), YSEU2(:), ZSEU2(:)
      LOGICAL :: WITH_WEIRS
!
!----------------------------------------------------------------------
!
      NDP_2D=3
!
      WRITE(LU,*) '+---- PARTEL: BEGINNING -------------+'
      CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
      TIMECOUNT = .TRUE.
      IF (PARSEC==0) TIMECOUNT = .FALSE.  ! COUNT_RATE == 0 : NO CLOCK
      IF (TIMECOUNT) TDEB = TEMPS
!
      CALL OPEN_MESH(FFORMAT, NAMEINP, NINP, 'READ     ', IERR)
      CALL CHECK_CALL(IERR, 'PARTEL:OPENMESH:INP')
!
      CALL OPEN_BND(FFORMAT,NAMECLI,NINP,'READ     ',IERR)
      CALL CHECK_CALL(IERR,'PARTEL:OPEN_BND:NCLI')
!
!----------------------------------------------------------------------
!
! START READING THE GEOMETRY OR RESULT FILE
!
      CALL READ_MESH_INFO(FFORMAT,NINP,TITLE,NVAR,NPOIN,TYP_ELEM,NELEM,
     &                    NPTFR,NPTIR,NDP,NPLAN,TYP_BND_ELEM,NELEBD)
!
      ! GET THE VARIABLES NAMES
      ALLOCATE(VAR_NAME(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VAR_NAME')
      ALLOCATE(VAR_UNIT(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VAR_UNIT')
      ALLOCATE(VARIABLE(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VAR_UNIT')

      CALL GET_DATA_VAR_LIST(FFORMAT,NINP,NVAR,VAR_NAME,VAR_UNIT,IERR)
      CALL CHECK_CALL(IERR,'PARTEL;GET_DATA_VAR_LIST:INP')
      DO I=1,NVAR
        VARIABLE(I)(1:16) = VAR_NAME(I)
        VARIABLE(I)(17:32) = VAR_UNIT(I)
      ENDDO
      DEALLOCATE(VAR_NAME)
      DEALLOCATE(VAR_UNIT)
!
! READ THE REST OF THE SELAFIN FILE
! 10 INTEGERS, THE FIRST IS THE NUMBER OF RECORDS (TIMESTEPS)
!
      CALL GET_MESH_DATE(FFORMAT,NINP,DATE_TMP,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_DATE:INP')
      DO I=1,3
        DATE(I) = DATE_TMP(I)
        TIME(I) = DATE_TMP(I+3)
      ENDDO
!
      IF(NPLAN.GT.1) THEN
        WRITE(LU,*) ' '
        WRITE(LU,*) '3D MESH DETECTED'
        NPOIN2 = NPOIN/NPLAN
        NELEM2 = NELEM/(NPLAN-1)
        WRITE(LU,*) 'NDP NODES PER ELEMENT:             ',NDP
        WRITE(LU,*) 'NPLAN NUMBER OF MESH LEVELS:       ',NPLAN
        WRITE(LU,*) 'NPOIN2 NUMBER OF 2D MESH NODES:    ',NPOIN2
        WRITE(LU,*) 'NPOIN NUMBER OF 3D MESH NODES:     ',NPOIN
        WRITE(LU,*) 'NELEM2 NUMBER OF 2D MESH ELEMENTS: ',NELEM2
        WRITE(LU,*) 'NELEM NUMBER OF 3D MESH ELEMENTS:  ',NELEM
        IF (MOD(NPOIN,NPLAN).NE.0) THEN
          WRITE (LU,*) 'BUT NPOIN2 /= NPOIN3/NPLAN!'
          CALL PLANTE(1)
          STOP
        ENDIF
        IF (MOD(NELEM,(NPLAN-1)).NE.0) THEN
          WRITE (LU,*) 'BUT NELEM2 /= NELEM3/NPLAN!'
          CALL PLANTE(1)
          STOP
        ENDIF
        WRITE(LU,*) ' '
        WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 3D'
        DIM_MESH = 3
      ELSE
        WRITE(LU,*) ' '
        WRITE(LU,*) 'ONE-LEVEL MESH.'
        WRITE(LU,*) 'NDP NODES PER ELEMENT:         ',NDP
        WRITE(LU,*) 'ELEMENT TYPE :                 ',TYP_ELEM
        WRITE(LU,*) 'NPOIN NUMBER OF MESH NODES:    ',NPOIN
        WRITE(LU,*) 'NELEM NUMBER OF MESH ELEMENTS: ',NELEM
        WRITE(LU,*) ' '
        NPOIN2 = NPOIN
        NELEM2 = NELEM
        WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 2D'
        DIM_MESH = 2
      ENDIF
!
! NOW LET US ALLOCATE
!
      ALLOCATE (IKLES(NELEM2*3),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IKLES')
      IF(NPLAN.GT.1) THEN
        ALLOCATE (IKLES3D(NELEM*NDP),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'IKLES3D')
      ENDIF
      ALLOCATE (IRAND(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IRAND')
!
!     SIZE 3: FIRST TWO FUNCTIONS ARE X AND Y, 3 IS ALL OTHER
!             VARIABLES (THEY WILL BE COPIED AND WRITTEN
!             ONE AFTER THE OTHER...)
!     NPOIN IS 3D HERE IN 3D
!
      ALLOCATE (F(NPOIN,2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'F')
!
! CONNECTIVITY TABLE:
!
      IF(NPLAN.LE.1) THEN
        CALL GET_MESH_CONNECTIVITY(FFORMAT,NINP,TYP_ELEM,IKLES,
     &                             NELEM,NDP,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_CONNECTIVITY:2D')
      ELSE
        CALL GET_MESH_CONNECTIVITY(FFORMAT,NINP,TYP_ELEM,IKLES3D,
     &                             NELEM,NDP,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_CONNECTIVITY:3D')
!       BUILDING IKLES
        DO J=1,3
          DO K=1,NELEM2
            IKLES((K-1)*3+J)=IKLES3D((K-1)*6+J)
          ENDDO
        ENDDO
      ENDIF
!
! BOUNDARY NODES INDICATIONS
!
      CALL GET_BND_IPOBO(FFORMAT,NINP,NPOIN,NPTFR,TYP_BND_ELEM,
     &                   IRAND,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_IPOBO:NINP')
!
! IRAND IS NOT ALWAYS CORRECT AND MAY LEAD TO ERRORS
! THE BO0UNDARY FILE IS USED INSTEAD
!
! X-, Y-COORDINATES
!
      CALL GET_MESH_COORD(FFORMAT,NINP,1,2,NPOIN,F(:,1),IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_COORD:X')
      CALL GET_MESH_COORD(FFORMAT,NINP,2,2,NPOIN,F(:,2),IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_COORD:Y')
!
      CALL GET_DATA_NTIMESTEP(FFORMAT,NINP,NTIMESTEP,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_DATA_NTIMESTEP')
!
      WRITE(LU,*) 'THERE ARE ',NTIMESTEP,' TIME-DEPENDENT RECORDINGS'
!
!----------------------------------------------------------------------
!
!     READ THE BOUNDARY CONDITIONS FILE
!
      !
      CALL GET_NODES_PER_ELEMENT(TYP_BND_ELEM,NDP_BND)
      ! Get the number of boundary points and elements
      CALL GET_BND_NELEM(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_NELEBD:NCLI')
      CALL GET_BND_NPOIN(FFORMAT,NINP,TYP_BND_ELEM,NPTFR,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_NPOIN:NCLI')
      !
      ALLOCATE(IKLE_BND(NELEBD*NDP_BND),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:IKLE_BND')
      ALLOCATE(NBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:NBOR')
      ! Allocating array for the boundary conditions
      ALLOCATE(LIHBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LIHBOR')
      ALLOCATE(LIUBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LIUBOR')
      ALLOCATE(LIVBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LIVBOR')
      ALLOCATE(HBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:HBOR')
      ALLOCATE(UBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:UBOR')
      ALLOCATE(VBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VBOR')
      ALLOCATE(CHBORD(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:CHBORD')
      ALLOCATE(LITBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LITBOR')
      ALLOCATE(TBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:TBOR')
      ALLOCATE(ATBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:ATBOR')
      ALLOCATE(BTBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:BTBOR')
      ALLOCATE (NUMLIQ(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NUMLIQ')
      ! Get the connectivity table for the boundary elements
      CALL GET_BND_CONNECTIVITY(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,
     &                    NDP_BND,IKLE_BND,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_CONNECTIVITY:NCLI')
      ! Fill NBOR
      CALL GET_BND_NUMBERING(FFORMAT,NINP,TYP_BND_ELEM,NPTFR,NBOR,IERR)
      ! Get the value of each boundary
      CALL GET_BND_VALUE(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,
     &                   LIHBOR,LIUBOR,
     &                   LIVBOR,HBOR,UBOR,VBOR,CHBORD,.TRUE.,
     &                   LITBOR,TBOR,ATBOR,BTBOR,NPTFR,NBOR,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_VALUE:NCLI')
      !
      CALL CLOSE_BND(FFORMAT,NINP,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:CLOSE_BND:NCLI')
!
!----------------------------------------------------------------------
! NUMBERING OF OPEN BOUNDARIES
! NUMBERING OF LIQUID BOUNDARY, IF 0 = SOLID
! OPN: NUMBER OF OPEN BOUNDARY
! IN ORDER TO DO IT IN THE SAME WAY AS TELEMAC DOES,
! IT IS BEST TO CALL FRONT2 HERE
!
! FOR CALLING BIEF MESH SUBROUTINES
! CAN BE OPTIMISED / USES A LOT OF MEMORY
! THE ONLY REASON IS TO OBTAIN KP1BOR AND NUMLIQ
!
      ALLOCATE (DEJAVU(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'DEJAVU')
      ALLOCATE (KP1BOR(NPTFR,2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'KP1BOR')
!     CHANGED NELEM TO NELEM2, NDP TO 3 HUH!
!     CAUSING ERRORS WHEN 3D RESTART/REFERENCE FILES ARE PARTITIONED
!     AND BC FILE IS WRITTEN AGAIN (WHAT FOR, ACTUALLY???)
!     CAUSE: CALLING VOISIN WITH NELEM2 BUT IFABOR(NELEM=NELEM3,NDP=6)
      ALLOCATE (IFABOR(NELEM2,3),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IFABOR')
      ALLOCATE (IFANUM(NELEM2,3),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IFANUM')
      ALLOCATE (IKLBOR(NPTFR,2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IKLBOR')
      ALLOCATE (NELBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NELBOR')
      ALLOCATE (NULONE(NPTFR,2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NULONE')
      ALLOCATE (ISEGF(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ISEGF')
      ALLOCATE (IKLE(NELEM2,3),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IKLE')
      ALLOCATE (IT1(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IT1')
      ALLOCATE (IT2(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IT2')
      ALLOCATE (IT3(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IT3')
      NPTIR = 1
      ALLOCATE (NACHB(NBMAXNSHARE,NPTIR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NACHB')
!
! TRANSFORM IKLES--> IKLE FOR 2D ROUTINES  (AN OLD TELEMAC DISEASE)
!
      DO I = 1,3
        DO J  = 1,NELEM2
          IKLE(J,I) = IKLES((J-1)*3+I)
        ENDDO
      ENDDO
!
      ! SET NCSIZE TO 1 TO USE VOISIN IN SERIAL MODE
      NCSIZE =  1

      CALL VOISIN(IFABOR, NELEM2, NELEM2, 11, IKLE, NELEM2,
     &                   NPOIN2, NACHB, NBOR(1:NPTFR), NPTFR, IT1, IT2)
      DEALLOCATE(NACHB)
!
      CALL ELEBD (NELBOR, NULONE, KP1BOR, IFABOR, NBOR(1:NPTFR), IKLE,
     &                   NELEM2, IKLBOR, NELEM2, NELEM2,
     &                   NPOIN2, NPTFR, 11, LIHBOR, 2, IFANUM,
     &                   1, ISEGF, IT1, IT2, IT3 ,
     &                   NPTFR ,NPTFR)
!                        NELEBX,NELEB (EQUAL NPTFR HERE)
!
      IF (NAMEINP(1:3)== 'ART') THEN
        CALL GET_FREE_ID(ID)
        OPEN(UNIT=ID,FILE='FRONT_GLOB.DAT')
        WRITE(ID,*) NPOIN
        WRITE(ID,*) NPTFR
        DO K=1,NPTFR
          WRITE(ID,*) NBOR(K)
        END DO
        DO K=1,NPTFR
          WRITE(ID,*) KP1BOR(K,1)
        END DO
        DO K=1,NPTFR
          WRITE(ID,*) KP1BOR(K,2)
        END DO
        CLOSE(ID)
      END IF
      NFRLIQ = 0
      IF(DIM_MESH.NE.3) THEN
        CALL FRONT2
     &         (NFRLIQ,
     &         LIHBOR,LIUBOR,F(:,1),F(:,2),
     &         NBOR,KP1BOR(1:NPTFR,1),DEJAVU,NPOIN2,NPTFR,
     &         2,.TRUE.,NUMLIQ,MAXFRO)
      ENDIF
!
      DEALLOCATE (DEJAVU)
!JAJ //// IFABOR APPLIED LATER FOR FINDING HALO CELL NEIGHBOURHOODS
!      DEALLOCATE (IFABOR)
      DEALLOCATE (IFANUM)
      DEALLOCATE (IKLBOR)
      DEALLOCATE (NULONE)
      DEALLOCATE (ISEGF)
      DEALLOCATE (IT1)
      DEALLOCATE (IT2)
      DEALLOCATE (IT3)
!
!======================================================================
! PARTITIONING
!
!
!
!======================================================================
! STEP 2 : PARTITIONING THE MESH
!
! OTHER PARTITIONING METHODS SHOULD BE USED (SCOTCH FOR EXAMPLE)
!     ALL PROCESSORS PERFORM THIS TASK TO AVOID COMMUNICATION
!     THE USE OF PARMETIS OR PTSCOTCH COULD BE USED FOR LARGER MESHES
!     IF THERE WILL BE SOME MEMORY ALLOCATION PROBLEM
!======================================================================
!
      ALLOCATE(EPART(NELEM2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'EPART')
      ALLOCATE(NPART(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPART')
!
!     PARTITIONNING METHOD
!     1 : METIS
!     2 : SCOTCH
      WRITE(LU,*) ' THE MESH PARTITIONING STEP STARTS'
      IF(TIMECOUNT) THEN
!       CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
        TDEBP = TEMPS
      ENDIF
      CALL PARTITIONER(PMETHOD, NELEM2, NPOIN2, 3, NPARTS,
     &                 IKLES, EPART, NPART)
      IF (TIMECOUNT) THEN
!       CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
        TFINP = TEMPS
        WRITE(LU,*) ' RUNTIME OF METIS ',
     &            (1.0*(TFINP-TDEBP))/(1.0*PARSEC),' SECONDS'
      ENDIF
      WRITE(LU,*) ' THE MESH PARTITIONING STEP HAS FINISHED'
!
!
!----------------------------------------------------------------------
!
!======================================================================
! STEP 3 : ALLOCATE THE GLOBAL  ARRAYS NOT DEPENDING OF THE PARTITION
!
!======================================================================
!
!     KNOGL(I) =>  GLOBAL LABEL OF THE LOCAL POINT I
!
      ALLOCATE (KNOGL(NPOIN2,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'KNOGL')
      DO I=1,NPOIN2
        DO J=1,NPARTS
          KNOGL(I,J)=0
        ENDDO
      ENDDO
!
!     NBRE_EF(I) => NUMBER OF FINITE ELEMENT CONTAINING I
!     I IS A GLOBAL LABEL
      ALLOCATE (NBRE_EF(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NBRE_EF')
!
      ALLOCATE (PART_P(NPOIN2,0:NBMAXNSHARE),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'PART_P')
      PART_P(:,:)=0
!
      ALLOCATE (CUT_P(NPOIN2,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'CUT_P')
!
      ALLOCATE (GELEGL(NELEM2,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'GELEGL')

      ALLOCATE (SORT(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'CUT_P')

      ALLOCATE (CUT(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'CUT_P')

      ALLOCATE (NELEM_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NELEM_P')

      ALLOCATE (NPOIN_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPOIN_P')

      ALLOCATE (NPTFR_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPTFR_P')

      ALLOCATE (NPTIR_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPTIR_P')

      ALLOCATE (NHALO(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NHALO')

      ALLOCATE(TAB_TMP( NBMAXNSHARE),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'TAB_TMP')

      ALLOCATE(IFAPAR(NPARTS,7,NBMAXHALO),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IFAPAR')
      IFAPAR(:,:,:)=0
!
!======================================================================
! STEP 4 : COMPUTE THE NUMBER OF FINITE ELEMENTS AND POINTS
!     BELONGING TO SUBMESH I
!
!======================================================================
!

!     FIRSTLY, ALL MPI PROCESSES  WORK ON THE WHOLE MESH
!     ----------------------------------------------
!
!     LOOP OVER THE FINITE ELEMENT OF THE MESH
!     TO COMPUTE THE NUMBER OF FINITE ELEMENTS CONTAINING EACH POINT NOEUD
      IF (NAMEINP(1:3) == 'ART') THEN
        DO EF=1,NELEM2
          DO K=1,NDP_2D
            NOEUD=IKLES((EF-1)*3+K)
            IF (IRAND(NOEUD) .NE. 0) THEN
              EPART(EF)=1
            END IF
          END DO
        END DO
      END IF

      NBRE_EF(:)=0
      DO EF=1,NELEM2
        DO K=1,NDP_2D
          NOEUD=IKLES((EF-1)*3+K)
          NBRE_EF(NOEUD)=NBRE_EF(NOEUD)+1
        END DO
      END DO
      DO I=1,NPARTS
!
!       LOOP OVER THE FINITE ELEMENT OF THE MESH TO COMPUTE
!       THE NUMBER OF THE FINITE ELEMENT AND POINTS BELONGING
!       TO SUBMESH I
!
        NELEM_P(I)=0
        NPOIN_P(I)=0
        DO EF=1,NELEM2
          IF(EPART(EF).EQ.I) THEN
            NELEM_P(I)=NELEM_P(I)+1
            DO K=1,NDP_2D
              NOEUD=IKLES((EF-1)*3+K)
              IF (KNOGL(NOEUD,I) .EQ. 0) THEN
                NPOIN_P(I)=NPOIN_P(I)+1
                KNOGL(NOEUD,I)=NPOIN_P(I)
              END IF
            END DO
          END IF
        END DO
      END DO
!
!======================================================================
!     STEP 4 : ALLOCATION OF LOCAL ARRAYS NEEDED BY MPI PROCESSUS ID
!              WORKING ON SUBMESH ID+1
!======================================================================
!
      MAX_NELEM_P=MAXVAL(NELEM_P)
      MAX_NPOIN_P=MAXVAL(NPOIN_P)
!
!     ELEGL(E) => GLOBAL LABEL OF THE FINITE ELEMENT E
!     E IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (ELELG(MAX_NELEM_P,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ELELG')
      ELELG(:,:)=0
!     KNOLG(I) => GLOBAL LABEL OF THE POINT I
!     I IS THE LOCAL LABEL ON SUBDOMAIN I
      IF(NPLAN.LE.0) THEN
        ALLOCATE (KNOLG(MAX_NPOIN_P,NPARTS),STAT=IERR)
      ELSE
        ALLOCATE (KNOLG(MAX_NPOIN_P*NPLAN,NPARTS),STAT=IERR)
      ENDIF
      CALL CHECK_ALLOCATE(IERR, 'KNOLG')
      KNOLG(:,:)=0
!     NBRE_EF_LOC(I) : NUMBER OF FINITE ELEMENTS CONTAINING THE POINT I
!                      ON SUBMESH I
!     I IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (NBRE_EF_LOC(MAX_NELEM_P),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NBRE_EF_LOC')
!
!     EF_I(E) IS THE GLOBAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_I(MAX_NELEM_P),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'EF_I')
!     EF_II(E) IS THE LOCAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_II(MAX_NELEM_P),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'EF_II')
!
!======================================================================
!     STEP 5 : INITIALISATION  OF LOCAL ARRAYS
!              (GELELG AND ELELG, NBRE_EF_LOC)
!======================================================================
!
      DO I=1,NPARTS
        NELEM_P(I)=0
        DO EF=1,NELEM2
          IF(EPART(EF).EQ.I) THEN
            NELEM_P(I)=NELEM_P(I)+1
            ELELG(NELEM_P(I),I)=EF
            GELEGL(EF,I)=NELEM_P(I)
          ENDIF
        ENDDO
        DO J=1,NPOIN_P(I)
          NBRE_EF_LOC(J)=0
        ENDDO
!
!======================================================================
!     STEP 5 : COMPUTE THE NUMBER OF BOUNDARY AND INTERFACE POINTS
!              INITIALISATION OF NBRE_EF_LOC
!======================================================================
!
        NPOIN_P(I)=0
        NPTFR_P(I)=0
        NBRE_NOEUD_INTERNE=0
!
        DO J=1,NELEM_P(I)
          EF=ELELG(J,I)
          DO K=1,3
            NOEUD=IKLES((EF-1)*3+K)
            NBRE_EF_LOC(KNOGL(NOEUD,I))=NBRE_EF_LOC(KNOGL(NOEUD,I))+1
            IF(NBRE_EF_LOC(KNOGL(NOEUD,I)) .EQ. 1) THEN
!             THE POINT NOEUD IS ENCOUNTERED FOR THE FIRST TIME
              NPOIN_P(I)=NPOIN_P(I)+1
!             IS NOEUD A BOUNDARY POINT ?
              IF(IRAND(NOEUD) .NE. 0) THEN
                NPTFR_P(I)= NPTFR_P(I)+1
              ENDIF
!             MODIFICATION OF KNOGL
              KNOLG(NPOIN_P(I),I)=NOEUD
            ENDIF
!           NOEUD IS A INTERNAL POINT IF ALL FINITE ELEMENTS
!           CONTAINING IT BELONGS TO THE SAME SUBMESH
            IF(NBRE_EF_LOC(KNOGL(NOEUD,I)) .EQ. NBRE_EF(NOEUD)) THEN
              NBRE_NOEUD_INTERNE=NBRE_NOEUD_INTERNE+1
            ENDIF
          ENDDO
        ENDDO
!
        NPTIR_P(I)=0
!
!       NOMBRE DE NOEUD INTERFACE DU SDI
!
        NBRE_EF_I=0            ! NOMBRE D'ELEMENTS FINIS INTERFACES DU SDI
        DO J=1,NELEM_P(I)      ! ON PARCOURS A NOUVEAU LES ELEMENTS FINIS DU SDI
          INTERFCE=.FALSE.
          EF=ELELG(J,I)
          DO K=1,NDP_2D
            NOEUD=IKLES((EF-1)*3+K)
            IF(ABS(NBRE_EF_LOC(KNOGL(NOEUD,I))).NE.NBRE_EF(NOEUD))
     &       THEN
              INTERFCE=.TRUE.
            ENDIF
            IF(NBRE_EF_LOC(KNOGL(NOEUD,I)).NE.NBRE_EF(NOEUD).AND.
     &         NBRE_EF_LOC(KNOGL(NOEUD,I)).GT.0) THEN
!             NOEUD EST INTERFACE CAR IL RESTE DES ELEMENTS FINIS
!             HORS DE SDI QUI LE CONTIENT
              INTERFCE=.TRUE.
              NPTIR_P(I)=NPTIR_P(I)+1
              CUT_P(NPTIR_P(I),I)=NOEUD
              PART_P(NOEUD,0)=PART_P(NOEUD,0)+1
              POSI=PART_P(NOEUD,0)
              IF(POSI.GT.NBMAXNSHARE-1) THEN
                WRITE(LU,*)  'ERROR : AN INTERFACE NODE BELONGS TO
     &                MORE THAN NBMAXNSHARE-1 SUBDOMAINS'
                CALL PLANTE(1)
                STOP
              ENDIF
              PART_P(NOEUD,POSI)=I
              NBRE_EF_LOC(KNOGL(NOEUD,I))=-NBRE_EF_LOC(KNOGL(NOEUD,I))
            ENDIF
          ENDDO
          IF(INTERFCE) THEN
            NBRE_EF_I=NBRE_EF_I+1 ! L'ELEMENT FINI EST DONC AUSSI INTERFACE
            EF_I(NBRE_EF_I)=EF
            EF_II(NBRE_EF_I)=J
          ENDIF
        ENDDO
!
!       FIRST LOOP TO COMPUTE THE NUMBER OF HALO TO ALLOCATE IFAPAR
!
!       FILLING IFAPAR
!
        NHALO(I)=0
        DO J=1,NBRE_EF_I  ! ON PARCOURT JUSTE LES ELEMENTS FINIS INTERFACES POUR
                          ! DETERMINER DES HALO
          EF=EF_I(J)
          HALO=.FALSE.
          IFALOC(:)=IFABOR(EF,:)
          WHERE (IFALOC .GT. 0)
             IFALOC=EPART(IFALOC)
          END WHERE
          HALO=ANY(IFALOC .GT. 0 .AND. IFALOC .NE. I)
          IF(HALO) THEN
            NHALO(I)=NHALO(I)+1
            IF(NHALO(I) > NBMAXHALO) THEN
              WRITE(LU,*)  'ERROR : NBMAXHALO TOO SMALL'
              CALL PLANTE(1)
              STOP
            ENDIF
            IFAPAR(I,1,NHALO(I))=EF_II(J)
            IFAPAR(I,2:4,NHALO(I))=IFALOC(:)
            IFAPAR(I,5:7,NHALO(I))=IFABOR(EF_I(J),:)
          ENDIF
        ENDDO
      ENDDO
!
      MAX_N_NEIGH=MAXVAL(PART_P(:,0))
      IF ( MAX_N_NEIGH > NBMAXNSHARE-1 ) THEN
        WRITE(LU,*) 'SERIOUS WARNING: '
        WRITE(LU,*)
     &       'AN INTERFACE NODE BELONGS TO ',
     &       'MORE THAN NBMAXNSHARE-1 SUBDOMAINS'
        WRITE(LU,*) 'TELEMAC MAY PROTEST!'
      ENDIF
      IF(MAX_N_NEIGH.GT.MAXNPROC) THEN
        WRITE (LU,*) 'THERE IS A NODE WHICH BELONGS TO MORE THAN ',
     &       MAXNPROC,' PROCESSORS, HOW COME?'
        CALL PLANTE(1)
        STOP
      ENDIF
      IF (MAX_N_NEIGH.LT.NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
!
      DO I=1,NPARTS
!
!-----------------------------------------------------------------------
! THE CORE NAMES FOR THE OUTPUT BC FILES ACCORDING TO THE NUMBER OF PARTS
!
        ! Working on the parallel informations
        IF(DIM_MESH.NE.3) THEN
        IF (CODE.NE.'  ') THEN
          NAMECLM = CODE//'PAR'//EXTENS(NPARTS-1,I-1)
        ELSE
          NAMECLM = NAMECLI(1:3)//'PAR'//EXTENS(NPARTS-1,I-1)
        ENDIF
        CALL GET_FREE_ID(NCLM)
        OPEN(NCLM,FILE=NAMECLM,STATUS='UNKNOWN',FORM='FORMATTED')
        REWIND(NCLM)
        WRITE(NCLM,*) NPTFR_P(I)
!
! FILE OPENED, NOW WORK ON BOUNDARIES
! -----------------------------------
!
! WHEN THE BOUNDARY NODE BELONGS TO THIS SUBDOMAIN IT WILL BE TAKEN
! J IS THE RUNNING BOUNDARY NODE NUMBER
!
        J = 0
        L = 0
!
        DO K=1,NPOIN_P(I)
          IF(IRAND(KNOLG(K,I)).NE.0) THEN
            L = L + 1
          ENDIF
        ENDDO
        DO K=1,NPTFR
!
!         BOUNDARY NODES BELONGING TO THIS PARTITION
!
          IF(KNOGL(NBOR(K),I).NE.0) THEN
            J = J + 1
            ISEG = 0
            XSEG = 0.0
            YSEG = 0.0
!
!           IF THE ORIGINAL (GLOBAL) BOUNDARY LEADS FURTHER INTO
!           ANOTHER PARTITION THEN ISEG IS SET NOT EQUAL TO ZERO
!           THE NEXT NODE ALONG THE GLOBAL BOUNDARY HAS IPTFR = M
!           (BUT CHECK THE CASE THE CIRCLE CLOSES)
!
            M = KP1BOR(K,1)
!
!           NBOR_P CANNOT BE USED, IT IS NOT FULLY FILLED WITH DATA
!
            ISO = 0
!           CHECKING IF THE ADJACENT ELEMENT IS NOT IN THE
!           SUB-DOMAIN
            IF (EPART(NELBOR(K)).NE.I) THEN
!
              ISEG = NBOR(M)
              XSEG = REAL(F(ISEG,1))
              YSEG = REAL(F(ISEG,2))
              ISO = ISO + 1
            ENDIF
!
            M = KP1BOR(K,2)
!
!           SAME AS ABOVE, BUT PREVIOUS SEGMENT ,THUS M, NOT K
            IF (EPART(NELBOR(M)).NE.I) THEN
              ISEG = -NBOR(M)
              XSEG = REAL(F(-ISEG,1))
              YSEG = REAL(F(-ISEG,2))
              ISO = ISO + 1
            ENDIF
!
!           WHEN BOTH NEIGHBOURS BOUNDARY NODES BELONG TO ANOTHER PARTITION
!
            IF (ISO == 2) THEN
              ISEG = -9999
              ISO = 0
              WRITE(LU,*) 'ISOLATED BOUNDARY POINT',
     &             NBOR(K), KNOGL(NBOR(K),I)
            ENDIF
!
!           WRITE Boundary parallel informatiosn
!           CONCERNING THE NODE WHICH HAS BEEN RESEARCHED
!
            WRITE (NCLM,*) K, KNOGL(NBOR(K),I),
     &                     ISEG, XSEG, YSEG, NUMLIQ(K)
          ENDIF
!
        END DO
!
!       Checking that there is not an error in the boundaries
        IF(J.NE.NPTFR_P(I)) THEN
          WRITE(LU,*) 'ERROR IN BOUNDARIES J=',J
          WRITE(LU,*) 'WHILE NPTFR_P(I)=',NPTFR_P(I)
          WRITE(LU,*) 'WHILE L=',L
          CALL PLANTE(1)
          STOP
        ENDIF


!
        FMT4='(I7)'
        WRITE (NCLM,*) NPTIR_P(I)
        IF (MAX_N_NEIGH < NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
        FMT4='(   (I7,1X))'
        WRITE (FMT4(2:4),'(I3)') MAX_N_NEIGH+1
!
!       SORTING NODE NUMBERS TO SORT(J) SO THAT CUT_P(SORT(J)) IS ORDERED
!       CUT IS OVERWRITTEN NOW
!
        DO J=1,NPTIR_P(I)
          CUT(J)=CUT_P(J,I)
        ENDDO
!
!       IF A NODE HAS BEEN ALREADY FOUND AS MIN, CUT(NODE) GETS 0
!
        DO J=1,NPTIR_P(I)
          IDUM = NPOIN2+1  ! LARGEST POSSIBLE NODE NUMBER + 1
          K=0
 401      CONTINUE
          K = K + 1
          IF ( CUT(K) /= 0 .AND. CUT_P(K,I) < IDUM ) THEN
            SORT(J) = K
            IDUM = CUT_P(K,I)
          ENDIF
          IF ( K < NPTIR_P(I) ) THEN
            GOTO 401
          ELSE
            CUT(SORT(J)) = 0
          ENDIF
        ENDDO
!
        DO J=1,NPTIR_P(I)
          TAB_TMP=0
          L=0
          DO K=1,MAX_N_NEIGH
            IF(PART_P(CUT_P(SORT(J),I),K) .NE. I .AND.
     &     PART_P(CUT_P(SORT(J),I),K) .NE. 0) THEN
              L=L+1
            TAB_TMP(L)=PART_P(CUT_P(SORT(J),I),K)
            ENDIF
          ENDDO
          WRITE(NCLM,FMT=FMT4) KNOGL(CUT_P(SORT(J),I),I),
     &                 (TAB_TMP(K)-1, K=1,MAX_N_NEIGH)
        ENDDO
!                                !
        DO J=1,NHALO(I)
          DO M=0,2
            IF (IFAPAR(I,2+M,J)>0) THEN
              IFAPAR(I,5+M,J)=GELEGL(IFAPAR(I,5+M,J),
     &             IFAPAR(I,2+M,J))
            END IF
          ENDDO
        ENDDO
        DO J=1,NHALO(I)
          DO M=0,2
            IF (IFAPAR(I,2+M,J)>0) THEN
              IFAPAR(I,2+M,J)=IFAPAR(I,2+M,J)-1
            END IF
          ENDDO
        ENDDO
!
        WRITE(NCLM,'(I9)') NHALO(I)
        DO K=1,NHALO(I)
          WRITE (NCLM,'(7(I9,1X))') IFAPAR(I,:,K)
        END DO
!
        CLOSE(NCLM)
        ENDIF
      END DO
!
      DEALLOCATE(IFAPAR)
      DEALLOCATE(PART_P)
      DEALLOCATE(NUMLIQ)
      DEALLOCATE(TAB_TMP)
      DEALLOCATE(GELEGL)
      DEALLOCATE(CUT)
      DEALLOCATE(CUT_P)
      DEALLOCATE(SORT)
!
      ALLOCATE(IKLES_P(MAX_NELEM_P*3),STAT=IERR)
      IF(NPLAN.GT.1) THEN
        ALLOCATE(IKLES3D_P(6,MAX_NELEM_P,NPLAN-1),STAT=IERR)
      ENDIF
      CALL CHECK_ALLOCATE(IERR, 'IKLES3D_P')
!
      DO I=1,NPARTS
!
        WRITE(LU,*) 'TREATING SUB-DOMAIN ', I
!
!       WRITING GEOMETRY FILES FOR ALL PARTS/PROCESSORS
!
        NAMEOUT = TRIM(NAMEINP)//EXTENS(NPARTS-1,I-1)
        NAMECLM = TRIM(NAMECLI)//EXTENS(NPARTS-1,I-1)
!
        CALL GET_FREE_ID(NOUT)
        CALL OPEN_MESH(FFORMAT,NAMEOUT,NOUT,'READWRITE',IERR)
        CALL CHECK_CALL(IERR,'PARTEL:OPEN_MESH:NOUT')
!
!       TITLE, THE NUMBER OF VARIABLES
!
        CALL SET_HEADER(FFORMAT,NOUT,TITLE,NVAR,VARIABLE,IERR)
!
!     The Mesh
!
        ALLOCATE(IKLE_P(NELEM_P(I)*3),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:IKLE_P')
        DO J=1,NELEM_P(I)
          EF=ELELG(J,I)
          DO K=1,3
            IKLE_P(J+(K-1)*NELEM_P(I)) = KNOGL(IKLES((EF-1)*3+K),I)
          ENDDO
        ENDDO
        IF(NPLAN.GT.1) THEN
          ALLOCATE(IKLE3D_P(NELEM_P(I)*6*(NPLAN-1)),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:IKLE_P')
          DO K = 1,NPLAN-1
            DO J = 1,NELEM_P(I)
              IKLE3D_P(J+(K-1)*NELEM_P(I) + (0*NELEM_P(I)*(NPLAN-1))) =
     &     IKLE_P(J + (0*NELEM_P(I))) + (K-1)*NPOIN_P(I)
              IKLE3D_P(J+(K-1)*NELEM_P(I) + (1*NELEM_P(I)*(NPLAN-1))) =
     &     IKLE_P(J + (1*NELEM_P(I))) + (K-1)*NPOIN_P(I)
              IKLE3D_P(J+(K-1)*NELEM_P(I) + (2*NELEM_P(I)*(NPLAN-1))) =
     &     IKLE_P(J + (2*NELEM_P(I))) + (K-1)*NPOIN_P(I)
              IKLE3D_P(J+(K-1)*NELEM_P(I) + (3*NELEM_P(I)*(NPLAN-1))) =
     &     IKLE_P(J + (0*NELEM_P(I))) + (K)*NPOIN_P(I)
              IKLE3D_P(J+(K-1)*NELEM_P(I) + (4*NELEM_P(I)*(NPLAN-1))) =
     &     IKLE_P(J + (1*NELEM_P(I))) + (K)*NPOIN_P(I)
              IKLE3D_P(J+(K-1)*NELEM_P(I) + (5*NELEM_P(I)*(NPLAN-1))) =
     &     IKLE_P(J + (2*NELEM_P(I))) + (K)*NPOIN_P(I)
            ENDDO
          ENDDO
        ENDIF
!
! INSTEAD OF IRAND, KNOLG IS WRITTEN !!!
! I.E. THE TABLE PROCESSOR-LOCAL -> PROCESSOR-GLOBAL NODE NUMBERS
!
        IF(NPLAN.EQ.0) THEN
          ALLOCATE(KNOLG_P(NPOIN_P(I)),STAT=IERR)
          CALL CHECK_CALL(IERR,'PARTEL:KNOLG_P:2D')
          DO J=1,NPOIN_P(I)
            KNOLG_P(J) = KNOLG(J,I)
          ENDDO
        ELSE
          ALLOCATE(KNOLG_P(NPOIN_P(I)*NPLAN),STAT=IERR)
          CALL CHECK_CALL(IERR,'PARTEL:KNOLG_P:3D')
          DO J=1,NPOIN_P(I)*NPLAN
            ! We fill knolg with dummy values because 3d knolg is never used
            KNOLG_P(J) = KNOLG(J,I)
          ENDDO
        ENDIF
!
! NODE COORDINATES X AND Y
!
        IF(NPLAN.EQ.0) THEN
          ALLOCATE(X(NPOIN_P(I)),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:X')
          ALLOCATE(Y(NPOIN_P(I)),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:Y')
          DO J=1,NPOIN_P(I)
            X(J) = F(KNOLG(J,I),1)
            Y(J) = F(KNOLG(J,I),2)
          ENDDO
        ELSE
          ALLOCATE(X(NPOIN_P(I)*NPLAN),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:X')
          ALLOCATE(Y(NPOIN_P(I)*NPLAN),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:Y')
          DO J=1,NPOIN_P(I)
            DO L=1,NPLAN
              X(J+(L-1)*NPLAN) = F(KNOLG(J,I)+(L-1)*NPOIN2,1)
              Y(J+(L-1)*NPLAN) = F(KNOLG(J,I)+(L-1)*NPOIN2,2)
            ENDDO
          ENDDO
        ENDIF
        IF(NPLAN.EQ.0) THEN
          CALL SET_MESH(FFORMAT,NOUT,2,TYP_ELEM,NDP,NPTFR_P(I),
     &                  NPTIR_P(I),NELEM_P(I),NPOIN_P(I),IKLE_P,
     &                  KNOLG_P,KNOLG_P,X,Y,NPLAN,DATE,TIME,
     &                  IERR)
          CALL CHECK_CALL(IERR,'PARTEL:SET_MESH:NOUT')
        ELSE
          CALL SET_MESH(FFORMAT,NOUT,3,TYP_ELEM,6,NPTFR_P(I),
     &                  NPTIR_P(I),NELEM_P(I)*(NPLAN-1),
     &                  NPOIN_P(I)*NPLAN,IKLE3D_P,
     &                  KNOLG_P,KNOLG_P,X,Y,NPLAN,DATE,TIME,
     &                  IERR)
          CALL CHECK_CALL(IERR,'PARTEL:SET_MESH:NOUT')
          DEALLOCATE(IKLE3D_P)
        ENDIF
        DEALLOCATE(X)
        DEALLOCATE(Y)
        DEALLOCATE(KNOLG_P)
        DEALLOCATE(IKLE_P)
!
!       WORK ON THE BOUNDARY CONDITIONS INFORMATIONS
!
        ! Compute the number of boundary_elements
        NELEBD_P = 0
        DO K=1,NELEBD
          FULLY_IN = .TRUE.
          DO L=1,NDP_BND
          ! If every point of the boundary element is in the partition then the element is as well
            IF(KNOGL(IKLE_BND(K+(L-1)*NELEBD),I).EQ.0) THEN
              FULLY_IN = .FALSE.
              EXIT
            ENDIF
          ENDDO
          ! IF
          IF(FULLY_IN) NELEBD_P = NELEBD_P + 1
        ENDDO
!
        ! Writing the boundary conditions
        CALL OPEN_BND(FFORMAT,NAMECLM,NOUT,'WRITE    ',IERR)
        CALL CHECK_CALL(IERR,'PARTEL:OPEN_BND')
        !
        ALLOCATE(IKLE_BND_P(NELEBD_P*NDP_BND),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:IKLE_BND_P')
        ALLOCATE(LIHBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:LIHBOR_P')
        ALLOCATE(LIUBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:LIUBOR_P')
        ALLOCATE(LIVBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:LIVBOR_P')
        ALLOCATE(HBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:HBOR_P')
        ALLOCATE(UBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:UBOR_P')
        ALLOCATE(VBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:VBOR_P')
        ALLOCATE(CHBORD_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:CHBORD_P')
        ALLOCATE(LITBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:LITBOR_P')
        ALLOCATE(TBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:TBOR_P')
        ALLOCATE(ATBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:ATBOR_P')
        ALLOCATE(BTBOR_P(NELEBD_P),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:BTBOR_P')
        J = 0
        DO K=1,NELEBD
          ! If both point of the segment are in the partition then the segment is in the partition
          FULLY_IN = .TRUE.
          DO L=1,NDP_BND
            IF(KNOGL(IKLE_BND(K+(L-1)*NELEBD),I).EQ.0) THEN
              FULLY_IN = .FALSE.
              EXIT
            ENDIF
          ENDDO
          IF(FULLY_IN) THEN
            J = J + 1
            M = IKLE_BND(K)
            DO N=1,NPTFR
              IF(NBOR(N).EQ.M) EXIT
            ENDDO
            LIHBOR_P(J) = LIHBOR(N)
            LIUBOR_P(J) = LIUBOR(N)
            LIVBOR_P(J) = LIVBOR(N)
            LITBOR_P(J) = LITBOR(N)
            DO L=1,NDP_BND
              M = IKLE_BND(K+(L-1)*NELEBD)
              IKLE_BND_P(J+(L-1)*NELEBD_P) = KNOGL(M,I)
              DO N=1,NPTFR
                IF(NBOR(N).EQ.M) EXIT
              ENDDO
              LIHBOR_P(J) = MIN(LIHBOR_P(J),LIHBOR(N))
              LIUBOR_P(J) = MIN(LIUBOR_P(J),LIUBOR(N))
              LIVBOR_P(J) = MIN(LIVBOR_P(J),LIVBOR(N))
              LITBOR_P(J) = MIN(LITBOR_P(J),LITBOR(N))
            ENDDO

            HBOR_P(J) = HBOR(K)
            UBOR_P(J) = UBOR(K)
            VBOR_P(J) = VBOR(K)
            CHBORD_P(J) = CHBORD(K)
            TBOR_P(J) = TBOR(K)
            ATBOR_P(J) = ATBOR(K)
            BTBOR_P(J) = BTBOR(K)
          ENDIF
        ENDDO
        CALL SET_BND(FFORMAT,NOUT,TYP_BND_ELEM,NELEBD_P,NDP_BND,
     &               IKLE_BND_P,LIHBOR_P,LIUBOR_P,
     &               LIVBOR_P,HBOR_P,UBOR_P,VBOR_P,CHBORD_P,
     &               LITBOR_P,TBOR_P,ATBOR_P,BTBOR_P,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:SET_BND')
        !
        CALL CLOSE_BND(FFORMAT,NOUT,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:CLOSE_BND')

        DEALLOCATE(IKLE_BND_P)
        DEALLOCATE(LIHBOR_P)
        DEALLOCATE(LIUBOR_P)
        DEALLOCATE(LIVBOR_P)
        DEALLOCATE(HBOR_P)
        DEALLOCATE(UBOR_P)
        DEALLOCATE(VBOR_P)
        DEALLOCATE(CHBORD_P)
        DEALLOCATE(LITBOR_P)
        DEALLOCATE(TBOR_P)
        DEALLOCATE(ATBOR_P)
        DEALLOCATE(BTBOR_P)
!
! TIME STAMP (SECONDS)
!
!!
!!   -------------------------------------------------------------------
!!   MODIFICATION TO PUT ALL THE RECORDINGS IN PARALLEL
!!   GEO FILE 08/06/2011
!!   -------------------------------------------------------------------
!!
!       EACH RECORDING IS READ AND ONLY THE LOCAL VARIABLES ARE STORED
!       INTO THE PARALLEL GEO FILE
!
        ALLOCATE(DATAVAL(NPOIN),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'PARTEL:DATAVAL')
        IF(NPLAN.LE.1) THEN
          ALLOCATE(DATAVAL_P(NPOIN_P(I)),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:DATAVAL')
        ELSE
          ALLOCATE(DATAVAL_P(NPOIN_P(I)*NPLAN),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'PARTEL:DATAVAL')
        ENDIF
        DO ITIME=1,NTIMESTEP
          CALL GET_DATA_TIME(FFORMAT,NINP,ITIME-1,TIMES,IERR)
          CALL CHECK_CALL(IERR,'PARTEL:GET_DATA_TIME:NINP')
          WRITE(LU,*) ' -- WRITING TIMESTEP',ITIME-1,' AT',real(TIMES)
          DO IVAR=1,NVAR
            ! READING VARIABLE VALUE FOR TIME ITIME-1 ON INPUT FILE
            CALL GET_DATA_VALUE(FFORMAT,NINP,ITIME-1,
     &                          VARIABLE(IVAR)(1:16),DATAVAL,NPOIN,IERR)
            CALL CHECK_CALL(IERR,'PARTEL:GET_DATA_VALUE:NINP')
            ! WRITING RESULT VALUE ON PARTITIONNED FILE
            IF(NPLAN.EQ.0) THEN
              ! 2D
              DO J=1,NPOIN_P(I)
                DATAVAL_P(J) = DATAVAL(KNOLG(J,I))
              ENDDO
              CALL ADD_DATA(FFORMAT,NOUT,VARIABLE(IVAR),TIMES,ITIME-1,
     &                      IVAR.EQ.1,DATAVAL_P,NPOIN_P(I),IERR)
              CALL CHECK_CALL(IERR,'PARTEL:ADD_DATA')
            ELSE
              ! 3D
              DO J=1,NPOIN_P(I)
                DO L=1,NPLAN
                  DATAVAL_P(J + (L-1)*NPOIN_P(I)) =
     &                       DATAVAL(KNOLG(J,I)+(L-1)*NPOIN2)
                ENDDO
              ENDDO
              CALL ADD_DATA(FFORMAT,NOUT,VARIABLE(IVAR),TIMES,ITIME-1,
     &                      IVAR.EQ.1,DATAVAL_P,NPOIN_P(I)*NPLAN,IERR)
              CALL CHECK_CALL(IERR,'PARTEL:ADD_DATA')
            ENDIF
          ENDDO
        ENDDO
        DEALLOCATE(DATAVAL)
        DEALLOCATE(DATAVAL_P)
        CALL CLOSE_MESH(FFORMAT,NOUT,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:CLOSE_MESH:NOUT')
      ENDDO
      CALL CLOSE_MESH(FFORMAT,NINP,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:CLOSE_MESH:NINP')
      DEALLOCATE(NBOR)
      DEALLOCATE(LIHBOR)
      DEALLOCATE(LIUBOR)
      DEALLOCATE(LIVBOR)
      DEALLOCATE(HBOR)
      DEALLOCATE(UBOR)
      DEALLOCATE(VBOR)
      DEALLOCATE(CHBORD)
      DEALLOCATE(LITBOR)
      DEALLOCATE(TBOR)
      DEALLOCATE(ATBOR)
      DEALLOCATE(BTBOR)
!   -------------------------------------------------------------------
! //// JAJ: LA FINITA COMMEDIA FOR PARALLEL CHARACTERISTICS, BYE!
!----------------------------------------------------------------------
! !JAJ #### DEAL WITH SECTIONS
!
      WITH_SECTIONS = NAMESEC(1:1) .NE. ' '
      IF (NPLAN.NE.0) WITH_SECTIONS=.FALSE.
      IF (WITH_SECTIONS) THEN ! PRESENTLY, FOR TELEMAC2D, EV. SISYPHE
!
      WRITE(LU,*) 'DEALING WITH SECTIONS WITH FILE ',TRIM(NAMESEC)
      CALL GET_FREE_ID(NSCT)
      OPEN (NSCT,FILE=TRIM(NAMESEC),FORM='FORMATTED',STATUS='OLD')
      READ (NSCT,*) ! COMMENT LINE
      READ (NSCT,*) NSEC, IHOWSEC
      IF (.NOT.ALLOCATED(CHAIN)) ALLOCATE (CHAIN(NSEC))
      IF (IHOWSEC<0) THEN
        DO ISEC=1,NSEC
          READ (NSCT,*) CHAIN(ISEC)%DESCR
          READ (NSCT,*) CHAIN(ISEC)%NPAIR(:)
          CHAIN(ISEC)%XYBEG(1)=F(CHAIN(ISEC)%NPAIR(1),1)
          CHAIN(ISEC)%XYBEG(2)=F(CHAIN(ISEC)%NPAIR(1),2)
          CHAIN(ISEC)%XYEND(1)=F(CHAIN(ISEC)%NPAIR(2),1)
          CHAIN(ISEC)%XYEND(2)=F(CHAIN(ISEC)%NPAIR(2),2)
          WRITE(LU,*) 'SECTION ',CHAIN(ISEC)%DESCR
          WRITE(LU,*) 'BEGINS AT X=',CHAIN(ISEC)%XYBEG(1),
     &                         ' Y=',CHAIN(ISEC)%XYBEG(2)
          WRITE(LU,*) 'ENDS   AT X=',CHAIN(ISEC)%XYEND(1),
     &                         ' Y=',CHAIN(ISEC)%XYEND(2)
        ENDDO
      ELSE
        DO ISEC=1,NSEC
          READ (NSCT,*) CHAIN(ISEC)%DESCR
!##> JR @ RWTH: AVOID PART-REF WITH NON-ZERO RANK IN MODE T1V
          READ (NSCT,*)
     &    ( CHAIN(ISEC)%XYBEG(I), I = 1, SIZE(CHAIN(ISEC)%XYBEG(:),1) ),
     &    ( CHAIN(ISEC)%XYEND(I), I = 1, SIZE(CHAIN(ISEC)%XYEND(:),1) )
!          READ (NSCT,*) CHAIN(ISEC)%XYBEG(:), CHAIN(ISEC)%XYEND(:)
!##< JR @ RWTH
          CHAIN(ISEC)%NPAIR(:)=0
        ENDDO
      ENDIF
      CLOSE(NSCT)
!
!     IF TERMINAL POINTS GIVEN BY COORDINATES, FIND NEAREST NODES FIRST
!
      WRITE(LU,*) 'NPOIN:',NPOIN
      IF(IHOWSEC.GE.0) THEN
        DO ISEC=1,NSEC
          XA=F(1,1)
          YA=F(1,2)
          DMINB = (CHAIN(ISEC)%XYBEG(1)-XA)**2
     &          + (CHAIN(ISEC)%XYBEG(2)-YA)**2
          DMINE = (CHAIN(ISEC)%XYEND(1)-XA)**2
     &          + (CHAIN(ISEC)%XYEND(2)-YA)**2
          CHAIN(ISEC)%NPAIR(1)=1
          CHAIN(ISEC)%NPAIR(2)=1
          DO I=2,NPOIN ! COMPUTATIONALLY INTENSIVE
            XA=F(I,1)
            YA=F(I,2)
            DISTB = (CHAIN(ISEC)%XYBEG(1)-XA)**2
     &            + (CHAIN(ISEC)%XYBEG(2)-YA)**2
            DISTE = (CHAIN(ISEC)%XYEND(1)-XA)**2
     &            + (CHAIN(ISEC)%XYEND(2)-YA)**2
            IF ( DISTB < DMINB ) THEN
              CHAIN(ISEC)%NPAIR(1)=I
              DMINB=DISTB
            ENDIF
            IF ( DISTE < DMINE ) THEN
              CHAIN(ISEC)%NPAIR(2)=I
              DMINE=DISTE
            ENDIF
          ENDDO
          WRITE(LU,'(A,3(1X,I9))')
     &          ' -> SECTION, TERMINAL NODES: ',
     &          ISEC, CHAIN(ISEC)%NPAIR(:)
        ENDDO
      ELSE
        DO ISEC=1,NSEC
          WRITE(LU,'(A,1X,I9,4(1X,1PG13.6))')
     &          ' -> SECTION, TERMINAL COORDINATES: ', ISEC,
     &          CHAIN(ISEC)%XYBEG, CHAIN(ISEC)%XYEND
        ENDDO
      ENDIF
!
      WRITE(LU,*) 'NSEC,IHOWSEC: ',NSEC,IHOWSEC
      WRITE(LU,*) 'ANTICIPATED SECTIONS SUMMARY:'
      DO ISEC=1,NSEC
        WRITE(LU,*) CHAIN(ISEC)%DESCR
        WRITE(LU,*) CHAIN(ISEC)%XYBEG(:), CHAIN(ISEC)%XYEND(:)
        WRITE(LU,*) CHAIN(ISEC)%NPAIR(:)
      ENDDO
!
!     NOW FOLLOW THE FLUSEC SUBROUTINE IN BIEF TO FIND SECTIONS
!     IN THE GLOBAL MESH -> FILL THE FIELD LISTE
!
      ALLOCATE(LISTE(NSEMAX,2),STAT=IERR) ! WORKHORSE
      CALL CHECK_ALLOCATE(IERR, 'LISTE')
!
      DO ISEC =1,NSEC
!
        DEP = CHAIN(ISEC)%NPAIR(1)
        ARR = CHAIN(ISEC)%NPAIR(2)
!
        PT = DEP
        ISEG = 0
        DIST=(F(DEP,1)-F(ARR,1))**2+(F(DEP,2)-F(ARR,2))**2
!
 1010   CONTINUE ! A JUMP POINT
!
        DO IELEM =1,NELEM
          I1 = IKLE(IELEM,1)
          I2 = IKLE(IELEM,2)
          I3 = IKLE(IELEM,3)
          IF (PT.EQ.I1.OR.PT.EQ.I2.OR.PT.EQ.I3) THEN
            DIST1 = (F(I1,1)-F(ARR,1))**2 + (F(I1,2)-F(ARR,2))**2
            DIST2 = (F(I2,1)-F(ARR,1))**2 + (F(I2,2)-F(ARR,2))**2
            DIST3 = (F(I3,1)-F(ARR,1))**2 + (F(I3,2)-F(ARR,2))**2
            IF (DIST1.LT.DIST) THEN
              DIST = DIST1
              ELBEST = IELEM
              IGBEST = I1
              ILBEST = 1
              IF(I1.EQ.PT) ILPREC = 1
              IF(I2.EQ.PT) ILPREC = 2
              IF(I3.EQ.PT) ILPREC = 3
            ENDIF
            IF (DIST2.LT.DIST) THEN
              DIST = DIST2
              ELBEST = IELEM
              IGBEST = I2
              ILBEST = 2
              IF(I1.EQ.PT) ILPREC = 1
              IF(I2.EQ.PT) ILPREC = 2
              IF(I3.EQ.PT) ILPREC = 3
            ENDIF
            IF(DIST3.LT.DIST) THEN
              DIST = DIST3
              ELBEST = IELEM
              IGBEST = I3
              ILBEST = 3
              IF(I1.EQ.PT) ILPREC = 1
              IF(I2.EQ.PT) ILPREC = 2
              IF(I3.EQ.PT) ILPREC = 3
            ENDIF
          ENDIF
!
        END DO ! OVER ELEMENTS
!
        IF (IGBEST.EQ.PT) THEN
          WRITE(LU,*)'FLUSEC : ALGORITHM FAILED'
          CALL PLANTE(1)
          STOP
        ELSE
          PT = IGBEST
          ISEG = ISEG + 1
          IF (ISEG.GT.NSEMAX) THEN
            WRITE(LU,*) 'TOO MANY SEGMENTS IN A   '
            WRITE(LU,*) 'SECTION. INCREASE  NSEMAX'
            CALL PLANTE(1)
            STOP
          ENDIF
          LISTE(ISEG,1) = IKLE(ELBEST,ILPREC)
          LISTE(ISEG,2) = IKLE(ELBEST,ILBEST)
          IF (IGBEST.NE.ARR) GOTO 1010
        ENDIF
        CHAIN(ISEC)%NSEG = ISEG
        ALLOCATE (CHAIN(ISEC)%LISTE(CHAIN(ISEC)%NSEG,3), STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'CHAIN(ISEC)%LISTE')
        DO ISEG=1,CHAIN(ISEC)%NSEG
          CHAIN(ISEC)%LISTE(ISEG,1)=LISTE(ISEG,1)
          CHAIN(ISEC)%LISTE(ISEG,2)=LISTE(ISEG,2)
          CHAIN(ISEC)%LISTE(ISEG,3)=-1 ! INITIALISE... FOR DEVEL
        END DO
      ENDDO ! OVER SECTIONS
      DEALLOCATE (LISTE)
!
      ALLOCATE (ANPBEG(NBMAXNSHARE), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ANPBEG')
      ALLOCATE (ANPEND(NBMAXNSHARE), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ANPEND')
!
      DO ISEC=1,NSEC
        DO ISEG=1,CHAIN(ISEC)%NSEG
!
          NPBEG=COUNT( KNOGL(CHAIN(ISEC)%LISTE(ISEG,1),:)>0 )
          NPEND=COUNT( KNOGL(CHAIN(ISEC)%LISTE(ISEG,2),:)>0 )
!
          IF (NPBEG>NBMAXNSHARE .OR. NPEND>NBMAXNSHARE) THEN
            WRITE(LU,*) 'NPBEG OR NPEND: ',NPBEG,NPEND
            WRITE(LU,*) 'ARE LARGER THAN NBMAXNSHARE: ',NBMAXNSHARE
            CALL PLANTE(1)
            STOP
          ENDIF
!
          ! THE NICE AND USUAL CASE WHEN BOTH SEGMENT ENDS
          ! BELONG TO ONE SUBDOMAIN - ONLY ONE POSITION IN KNOGL
          IF ( NPBEG==1 .AND. NPEND==1) THEN
            IM(:) = MAXLOC ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,1),:) )
            IN(:) = MAXLOC ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,2),:) )
            IF (IM(1)==IN(1)) THEN
              CHAIN(ISEC)%LISTE(ISEG,3)=IM(1)
            ELSE ! THEY BELONG TO DIFFERENT SUBDOMAINS? HOW COME?
              WRITE(LU,*) 'IMPOSSIBLE CASE (1) BY SECTIONS'
              CALL PLANTE(1)
              STOP
            ENDIF
            ! AT LEAST ONE OF THE TERMINAL NODES IS ON THE INTERFACE
            ! TAKE THE LARGEST COMMON PARTITION NUMBER THEY BOTH BELONG TO
          ELSE
            IF (NPBEG==1 .AND. NPEND>1) THEN ! THE SEGMENT'S END TOUCHES THE INTERFACE
              IM(:) = MAXLOC ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,1),:) )
              IF ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,2),IM(1))>0 ) THEN
                CHAIN(ISEC)%LISTE(ISEG,3) = IM(1)
              ELSE
                WRITE(LU,*) 'IMPOSSIBLE CASE (2) BY SECTIONS'
                CALL PLANTE(1)
                STOP
              ENDIF
            ELSE IF (NPBEG>1 .AND. NPEND==1) THEN ! THE SEGMENT'S BEG. TOUCHES THE INTERFACE
              IN(:) = MAXLOC ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,2),:) )
              IF ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,1),IN(1))>0 ) THEN
                CHAIN(ISEC)%LISTE(ISEG,3) = IN(1)
              ELSE
                WRITE(LU,*) 'IMPOSSIBLE CASE (3) BY SECTIONS'
                CALL PLANTE(1)
                STOP
              ENDIF
            ELSE ! I.E. (NPBEG>1 .AND. NPEND>1) - LIES JUST ON THE INTERFACE OR "A SHORTCUT"
              ANPBEG=0
              ANPEND=0
              I=0
              DO N=1,NPARTS
                IF ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,1),N)>0 ) THEN
                  I=I+1
                  ANPBEG(I)=N
                ENDIF
              END DO
              IF (I/=NPBEG) WRITE(LU,*) 'OH! I/=NPBEG'
              I=0
              DO N=1,NPARTS
                IF ( KNOGL(CHAIN(ISEC)%LISTE(ISEG,2),N)>0 ) THEN
                  I=I+1
                  ANPEND(I)=N
                ENDIF
              END DO
              IF (I/=NPEND) WRITE(LU,*) 'OH! I/=NPEND'
!
              WRITE(LU,*) 'ANPBEG: ',ANPBEG
              WRITE(LU,*) 'ANPEND: ',ANPEND
!
              FOUND=.FALSE.
              DO I=NPBEG,1,-1
                DO J=NPEND,1,-1
                  IF (ANPBEG(I)==ANPEND(J)) THEN
                    CHAIN(ISEC)%LISTE(ISEG,3) = ANPBEG(I)
                    FOUND=.TRUE.
                    EXIT
                  ENDIF
                END DO
                IF (FOUND) EXIT
              END DO
              IF (.NOT.FOUND) THEN
                WRITE(LU,*) 'BY SECTION WITH NODES: ',
     &            CHAIN(ISEC)%LISTE(ISEG,1),CHAIN(ISEC)%LISTE(ISEG,2)
                WRITE(LU,*) 'IMPOSSIBLE CASE (4) BY SECTIONS'
                CALL PLANTE(1)
                STOP
              ENDIF

            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
      DEALLOCATE (ANPBEG,ANPEND)
!
! WRITE FILES
!
      DO N=1,NPARTS
        NAMEOUT=TRIM(NAMESEC)//EXTENS(NPARTS-1,N-1)

        WRITE(LU,*) 'WRITING: ', TRIM(NAMEOUT)

        OPEN (NOUT,FILE=TRIM(NAMEOUT),FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(NOUT)
        WRITE(NOUT,*) '# SECTIONS PARTITIONED FOR ',
     &   EXTENS(NPARTS-1,N-1)
        WRITE(NOUT,*) NSEC, 1
        DO ISEC=1,NSEC
          WRITE(NOUT,*) TRIM(CHAIN(ISEC)%DESCR)
          I=COUNT(CHAIN(ISEC)%LISTE(:,3)==N)
          WRITE(NOUT,*) I
          DO ISEG=1,CHAIN(ISEC)%NSEG
            IF (CHAIN(ISEC)%LISTE(ISEG,3)==N) THEN
              WRITE(NOUT,*)
     &          KNOGL(CHAIN(ISEC)%LISTE(ISEG,1),N),
     &          KNOGL(CHAIN(ISEC)%LISTE(ISEG,2),N)
            ENDIF
          END DO
        END DO
        CLOSE(NOUT)
      END DO
!
      WRITE(LU,*) 'FINISHED DEALING WITH SECTIONS'
      ENDIF ! NPLAN==0

! !YA #### DEAL WITH ZONES
!
!----------------------------------------------------------------------
!
      WITH_ZONES = NAMEZFI(1:1) .NE. ' '
      IF (NPLAN.NE.0) WITH_ZONES = .FALSE.
      IF(WITH_ZONES) THEN
!
      WRITE(LU,*) 'DEALING WITH ZONES WITH FILE ',TRIM(NAMEZFI)
!     Reading the friction informations
      CALL GET_FREE_ID(NZFI)
      OPEN(NZFI,FILE=TRIM(NAMEZFI),FORM='FORMATTED',STATUS='OLD')
      ALLOCATE (FRICTION(NPOIN), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'FRICTION')
      FRICTION(:) = 0
      DO J=1,NPOIN
        READ(NZFI,*,END=304,ERR=303) I, VAL_ZFI
        FRICTION(I) = VAL_ZFI
      ENDDO
      CLOSE(NZFI)
!
      DO N=1,NPARTS
        NAMEOUT=TRIM(NAMEZFI)//EXTENS(NPARTS-1,N-1)

        WRITE(LU,*) 'WRITING: ', TRIM(NAMEOUT)

        OPEN (NOUT,FILE=TRIM(NAMEOUT),FORM='FORMATTED',STATUS='NEW')
        DO I=1,NPOIN_P(N)
          I_GLOB = KNOLG(I,N)
          WRITE(NOUT,*) I, FRICTION(I_GLOB)
        END DO
        CLOSE(NOUT)
      END DO
      DEALLOCATE(FRICTION)
!
      WRITE(LU,*) 'FINISHED DEALING WITH ZONES'
      ENDIF ! WITH_ZONES
!
! !CCT #### DEAL WITH WEIRS
!
!----------------------------------------------------------------------
!
      WITH_WEIRS = NAMESEU(1:1) .NE. ' '
      IF (NPLAN.NE.0) WITH_WEIRS = .FALSE.
      IF(WITH_WEIRS) THEN
!
      WRITE(LU,*) 'DEALING WITH WEIRS WITH FILE ',TRIM(NAMESEU)
!     Reading the weirs informations
      CALL GET_FREE_ID(NSEU)
      OPEN(NSEU,FILE=TRIM(NAMESEU),FORM='FORMATTED',STATUS='OLD')
      READ(NSEU,*,END=304,ERR=305)
      READ(NSEU,*,END=304,ERR=305) NBSEU, OPSEU
      ALLOCATE (XSEU1(NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'XSEU1')
      XSEU1(:) = 0
      ALLOCATE (YSEU1(NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'YSEU1')
      YSEU1(:) = 0
      ALLOCATE (ZSEU1(NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ZSEU1')
      ZSEU1(:) = 0
      ALLOCATE (XSEU2(NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'XSEU2')
      XSEU2(:) = 0
      ALLOCATE (YSEU2(NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'YSEU2')
      YSEU2(:) = 0
      ALLOCATE (ZSEU2(NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ZSEU2')
      ZSEU2(:) = 0
      ALLOCATE (NUM_SEU1(4,NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NUM_SEU1')
      NUM_SEU1(:,:) = 0
      ALLOCATE (NUM_SEU2(4,NBSEU), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NUM_SEU2')
      NUM_SEU2(:,:) = 0
!
      DO J=1,NBSEU
        READ(NSEU,*,END=304,ERR=305) I,
     &       XSEU1(J), YSEU1(J), ZSEU1(J),
     &       (NUM_SEU1(K,J), K = 1,4),
     &       XSEU2(J), YSEU2(J), ZSEU2(J),
     &       (NUM_SEU2(K,J), K = 1,4)
      END DO
      CLOSE(NSEU)
!
      ALLOCATE (PART_P(NPOIN2,0:NBMAXNSHARE),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'PART_P')
      PART_P(:,:)=0
!     Partition of the global domain.
!     For each global node, PART_P gives the number and the list of SD which contains the node
      DO N=1,NPARTS
        DO I=1, NPOIN2
          IF (KNOGL(I,N).GT.0) THEN
            PART_P(I,0)=PART_P(I,0)+1
            POSI=PART_P(I,0)
            PART_P(I,POSI)=N
          ENDIF
        END DO
      END DO
!
      ALLOCATE (SEU_P(NBSEU,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'SEU_P')
      SEU_P(:,:)=0
      ALLOCATE (CSEU_P(NBSEU,0:NBMAXNSHARE),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'CSEU_P')
      CSEU_P(:,:)=0
      ALLOCATE (P_CSEU(NPARTS,0:NBSEU))
      CALL CHECK_ALLOCATE(IERR, 'P_CSEU')
      P_CSEU(:,:)=0
!     Partition of the element of weirs.
!     SEU_P indicate if the element of weir is computed or not by SD
      DO N=1,NPARTS
        DO J=1,NBSEU
          DO K=1,4
            IF (KNOGL(NUM_SEU1(K,J),N).GT.0) THEN
              SEU_P(J,N)=1
            END IF
            IF (KNOGL(NUM_SEU2(K,J),N).GT.0) THEN
              SEU_P(J,N)=1
            END IF
          END DO
        END DO
      END DO
!     Partition of the element of weirs.
!     For each element, CSEU_P gives the number and the list of SD which compute the discharge
      DO N=1,NPARTS
        DO J=1,NBSEU
          IF (SEU_P(J,N)>0) THEN
            CSEU_P(J,0)=CSEU_P(J,0)+1
            POSI=CSEU_P(J,0)
            CSEU_P(J,POSI)=N
          END IF
        END DO
      END DO
!     Partition of the element of weirs.
!     For each SD, P_CSEU gives the number and the list element of weir computed
      DO J=1,NBSEU
        DO L=1, CSEU_P(J,0)
          PROC = CSEU_P(J,L)
          P_CSEU(PROC,0) = P_CSEU(PROC,0)+1
          POSI = P_CSEU(PROC,0)
          P_CSEU(PROC,POSI) = J
        END DO
      END DO
!
      ALLOCATE (NRECV_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NRECV_P')
      NRECV_P(:)=0
      ALLOCATE (LRECV_P(8*NBSEU,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'LRECV_P')
      LRECV_P(:,:)=0
!     Informations on the nodes involved in the element of weirs computation
!     NRECV_P gives the numbers of nodes used in the computation for each SD
!     LRECV_P gives the list of nodes used in the computation for each SD
      DO N=1,NPARTS
        DO J=1,NBSEU
          IF (SEU_P(J,N)>0) THEN
            DO K=1,4
              DO L=1, NRECV_P(N)
                IF (NUM_SEU1(K,J) == LRECV_P(L,N)) GOTO 602
                IF (NUM_SEU1(K,J) < LRECV_P(L,N)) GOTO 601
              END DO
 601          CONTINUE
              NRECV_P(N)=NRECV_P(N)+1
              DO I= NRECV_P(N),L+1,-1
                LRECV_P(I,N) = LRECV_P(I-1,N)
              END DO
              LRECV_P(L,N)=NUM_SEU1(K,J)
 602          CONTINUE
!
              DO L=1, NRECV_P(N)
                IF (NUM_SEU2(K,J) == LRECV_P(L,N)) GOTO 604
                IF (NUM_SEU2(K,J) < LRECV_P(L,N)) GOTO 603
              END DO
 603          CONTINUE
              NRECV_P(N)=NRECV_P(N)+1
              DO I= NRECV_P(N),L+1,-1
                LRECV_P(I,N) = LRECV_P(I-1,N)
              END DO
              LRECV_P(L,N)=NUM_SEU2(K,J)
 604          CONTINUE
            END DO
          END IF
        END DO
      END DO
!
      ALLOCATE (NSEND_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NSEND_P')
      NSEND_P(:)=0
      ALLOCATE (LSEND_P(8*NBSEU,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'LSEND_P')
      LSEND_P(:,:)=0
      ALLOCATE (LSEND_PP(NBMAXNSHARE,8*NBSEU,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'LSEND_PP')
      LSEND_PP(:,:,:)=0
!     Informations on the nodes involved in the element of weirs computation
!     NSEND_P gives for each SD the numbers of nodes used in the computation of other SD
!     LSEND_P gives for each SD the list of nodes used in the computation of other SD
!     LSEND_PP gives for each SD and for each nodes used in the computation of other SD the list of SD
      DO J=1,NBSEU
        DO M=1, CSEU_P(J,0)
          N = CSEU_P(J,M)
          DO K=1,4
            IF(KNOGL(NUM_SEU1(K,J),N)>0) THEN
              DO L=1, NSEND_P(N)
                IF (NUM_SEU1(K,J) == LSEND_P(L,N)) GOTO 702
                IF (NUM_SEU1(K,J) < LSEND_P(L,N)) GOTO 701
              END DO
 701          CONTINUE
              NSEND_P(N)=NSEND_P(N)+1
              DO I= NSEND_P(N),L+1,-1
                LSEND_P(I,N) = LSEND_P(I-1,N)
                LSEND_PP(:,I,N) = LSEND_PP(:,I-1,N)
              END DO
              LSEND_P(L,N)=NUM_SEU1(K,J)
              LSEND_PP(:,L,N)=0
 702          CONTINUE
              DO I=1, CSEU_P(J,0)
                DO JJ = 1, NBMAXNSHARE
                  IF (CSEU_P(J,I) == LSEND_PP(JJ,L,N)) GOTO 703
                  IF (LSEND_PP(JJ,L,N) == 0) THEN
                    LSEND_PP(JJ,L,N) = CSEU_P(J,I)
                    GOTO 703
                  END IF
                END DO
 703            CONTINUE
              END DO
            END IF
!
            IF(KNOGL(NUM_SEU2(K,J),N)>0) THEN
              DO L=1, NSEND_P(N)
                IF (NUM_SEU2(K,J) == LSEND_P(L,N)) GOTO 705
                IF (NUM_SEU2(K,J) < LSEND_P(L,N)) GOTO 704
              END DO
 704          CONTINUE
              NSEND_P(N)=NSEND_P(N)+1
              DO I= NSEND_P(N),L+1,-1
                LSEND_P(I,N) = LSEND_P(I-1,N)
                LSEND_PP(:,I,N) = LSEND_PP(:,I-1,N)
              END DO
              LSEND_P(L,N)=NUM_SEU2(K,J)
              LSEND_PP(:,L,N)=0
 705          CONTINUE
              DO I=1, CSEU_P(J,0)
                DO JJ = 1, NBMAXNSHARE
                  IF (CSEU_P(J,I) == LSEND_PP(JJ,L,N)) GOTO 706
                  IF (LSEND_PP(JJ,L,N) == 0) THEN
                    LSEND_PP(JJ,L,N) = CSEU_P(J,I)
                    GOTO 706
                  END IF
                END DO
 706            CONTINUE
              END DO
            END IF
          END DO
        END DO
      END DO
!
      ALLOCATE (NUM_SEU1_P(4,NBSEU,NPARTS), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NUM_SEU1_P')
      NUM_SEU1_P(:,:,:)=0
      ALLOCATE (NUM_SEU2_P(4,NBSEU,NPARTS), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NUM_SEU2_P')
      NUM_SEU2_P(:,:,:)=0
!     Local numbering of nodes involved in element of weirs description
      DO N=1,NPARTS
        DO J=1,NBSEU
          IF (SEU_P(J,N)>0) THEN
            DO K=1,4
              DO L=1, NRECV_P(N)
                IF (NUM_SEU1(K,J)==LRECV_P(L,N)) THEN
                  NUM_SEU1_P(K,J,N) = L
                  GOTO 605
                END IF
              ENDDO
              WRITE(LU,*) 'HOUSTON ON A UN PROBLEME (1)', J, K, L
 605          CONTINUE
            END DO
!
            DO K=1,4
              DO L=1, NRECV_P(N)
                IF (NUM_SEU2(K,J)==LRECV_P(L,N)) THEN
                  NUM_SEU2_P(K,J,N) = L
                  GOTO 606
                END IF
              ENDDO
              WRITE(LU,*) 'HOUSTON ON A UN PROBLEME (2)', J, K, L
 606          CONTINUE
            END DO
          END IF
        END DO
      END DO
!
! WRITE THE WEIR FILE FOR EACH SUBDOMAIN
      DO N=1,NPARTS
        NAMEOUT=TRIM(NAMESEU)//EXTENS(NPARTS-1,N-1)
        WRITE(LU,*) 'WRITING: ', TRIM(NAMEOUT)
        OPEN (NOUT,FILE=TRIM(NAMEOUT),FORM='FORMATTED',STATUS='NEW')
        WRITE(NOUT,*) ' Nb de singularites Option Utan'
        WRITE(NOUT,*) SUM(SEU_P(:,N)), OPSEU
! WRITE THE DESCRIPTION OF ELEMENTS OF WEIRS
        DO J=1,NBSEU
          IF (SEU_P(J,N)>0) THEN
            WRITE(NOUT,*) J,
     &         XSEU1(J), YSEU1(J), ZSEU1(J),
     &         (NUM_SEU1_P(K,J,N), K = 1,4),
     &         XSEU2(J), YSEU2(J), ZSEU2(J),
     &         (NUM_SEU2_P(K,J,N), K = 1,4)
          END IF
        END DO
! WRITE THE PARALLEL INFORMATION WHICH DESCRIBE WHICH SUBDOMAIN NEED TO COMPUTE EACH ELEMENT
        WRITE(NOUT,*) ' // : for each element, number and list of SD',
     &                ' which will also compute discharge on it'
!
        ALLOCATE (LIST_TMP(1,NBMAXNSHARE),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'LIST_TMP')
        DO J=1,NBSEU
          IF (SEU_P(J,N)>0) THEN
            LIST_TMP(:,:)=0
            I = 0
            DO K=1, NBMAXNSHARE
              IF((CSEU_P(J,K)>0).AND.(CSEU_P(J,K)/=N)) THEN
                I = I + 1
                LIST_TMP(1,I) = CSEU_P(J,K)
              END IF
            END DO
            WRITE(NOUT,*) J, I
            IF (I>0) THEN
              WRITE(NOUT,*) (LIST_TMP(1,K)-1, K=1,I)
            END IF
          END IF
        END DO
        DEALLOCATE (LIST_TMP)
!
        WRITE(NOUT,*) ' // : for each SD, number and list of element',
     &                ' which will be computed'
!       first passage to count the number of sd and write it in the file
        PROC = 0
        DO L=1, NPARTS
          IF (L/=N) THEN
            DO J=1,P_CSEU(L,0)
              IF (SEU_P(P_CSEU(L,J),N)>0) THEN
                PROC = PROC + 1
                GOTO 501
              END IF
            END DO
          END IF
 501      CONTINUE
        END DO
        WRITE(NOUT,*) PROC
!
        ALLOCATE (LIST_TMP(1,NBSEU),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'LIST_TMP')
        LIST_TMP(:,:)=0
        DO L=1, NPARTS
          IF (L/=N) THEN
            I = 0
            DO J=1,P_CSEU(L,0)
              IF (SEU_P(P_CSEU(L,J),N)>0) THEN
                I = I + 1
                LIST_TMP(1,I) = P_CSEU(L,J)
              END IF
            END DO
            IF (I>0) THEN
              WRITE(NOUT,*) L-1, I
              WRITE(NOUT,*) (LIST_TMP(1,K), K=1,I)
            END IF
          END IF
        END DO
        DEALLOCATE (LIST_TMP)
! WRITE THE PARALLEL INFORMATION ABOUT THE NODES INVOLVED IN WEIR DESCRIPTION
! THE VALUES OF THESE NODES SHOULD BE RECEIVE FROM OTHER SD
        WRITE(NOUT,*) ' // : for each node required by the SD to',
     &                ' compute the discharge, number, list and local',
     &                ' numbering of nodes from all involved SD'
        ALLOCATE (LIST_TMP(2,NBMAXNSHARE),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'LIST_TMP')
        WRITE(NOUT,*) NRECV_P(N)
        IF (NRECV_P(N)>0) THEN
          DO I=1, NRECV_P(N)
            LIST_TMP(:,:)=0
            J = 0
            DO K=1, PART_P(LRECV_P(I,N),0)
              J = J + 1
              LIST_TMP(1,K) = PART_P(LRECV_P(I,N),K)
              LIST_TMP(2,K) = KNOGL(LRECV_P(I,N),PART_P(LRECV_P(I,N),K))
            END DO
            WRITE(NOUT,*) LRECV_P(I,N), J
            WRITE(NOUT,*) (LIST_TMP(1,K)-1,LIST_TMP(2,K),
     &                    K=1,J)
          END DO
        END IF
        DEALLOCATE (LIST_TMP)
!
        WRITE(NOUT,*) ' // : for each other SD which send values,',
     &                ' number and list of node (with local number)'
        IF (NRECV_P(N)>0) THEN
          ALLOCATE (LIST_TMP(NPARTS,3*NRECV_P(N)),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR, 'LIST_TMP')
          LIST_TMP(:,:)=0
        END IF
        PROC = 0
        IF (NRECV_P(N)>0) THEN
          DO I=1, NRECV_P(N)
            DO K=1, PART_P(LRECV_P(I,N),0)
              DO J=1, PROC
                IF (LIST_TMP(J,1) == PART_P(LRECV_P(I,N),K)) GOTO 522
                IF (LIST_TMP(J,1) >  PART_P(LRECV_P(I,N),K)) GOTO 521
              END DO
 521          CONTINUE
              PROC = PROC + 1
              DO M = PROC, J+1, -1
                LIST_TMP(M,1) = LIST_TMP(M-1,1)
              END DO
              LIST_TMP(J,1) = PART_P(LRECV_P(I,N),K)
 522          CONTINUE
            END DO
          END DO
        END IF
        WRITE(NOUT,*) PROC
!
        DO M=1, PROC
          POSI = 2
          DO I=1, NRECV_P(N)
            JJ = LRECV_P(I,N)
            DO K=1, PART_P(JJ,0)
              IF (PART_P(JJ,K)==LIST_TMP(M,1)) THEN
                LIST_TMP(M,POSI  ) = I
                LIST_TMP(M,POSI+1) = JJ
                LIST_TMP(M,POSI+2) = KNOGL(JJ,PART_P(JJ,K))
                POSI = POSI + 3
              END IF
            END DO
          END DO
          WRITE(NOUT,*) LIST_TMP(M,1)-1, (POSI-1)/3
          IF (POSI > 2) THEN
            WRITE(NOUT,*) (LIST_TMP(M,3*K-1), K=1,(POSI-1)/3)
            WRITE(NOUT,*) (LIST_TMP(M,3*K  ), K=1,(POSI-1)/3)
            WRITE(NOUT,*) (LIST_TMP(M,3*K+1), K=1,(POSI-1)/3)
          END IF
        END DO
        IF (ALLOCATED(LIST_TMP)) DEALLOCATE(LIST_TMP)
!
! WRITE THE PARALLEL INFORMATION ABOUT THE NODES INVOLVED IN WEIR DESCRIPTION OF OTHER SD
! THE VALUES OF THESE NODES SHOULD BE SEND TO OTHER SD
        WRITE(NOUT,*) ' // : for each node inside the SD, number and',
     &                ' list of others SD which also need the value'
        ALLOCATE (LIST_TMP(2,NBMAXNSHARE),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'LIST_TMP')
        WRITE(NOUT,*) NSEND_P(N)
        IF (NSEND_P(N)>0) THEN
          DO I=1, NSEND_P(N)
            LIST_TMP(:,:)=0
            J = 0
            DO K=1, NBMAXNSHARE
              IF (LSEND_PP(K,I,N)>0) THEN
                J = J + 1
                LIST_TMP(1,J) = LSEND_PP(K,I,N)
              END IF
            END DO
            WRITE(NOUT,*) LSEND_P(I,N), J
            WRITE(NOUT,*) (LIST_TMP(1,K)-1, K=1,J)
          END DO
        END IF
        DEALLOCATE (LIST_TMP)
!
        WRITE(NOUT,*) ' // : for each other SD which needs node ',
     &                'values, number and list of nodes'
        IF (NSEND_P(N)>0) THEN
          ALLOCATE (LIST_TMP(NPARTS,3*NSEND_P(N)),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR, 'LIST_TMP')
          LIST_TMP(:,:)=0
        END IF
        PROC = 0
        IF (NSEND_P(N)>0) THEN
          DO I=1, NSEND_P(N)
            DO K=1, NBMAXNSHARE
              IF (LSEND_PP(K,I,N)>0) THEN
                DO J=1, PROC
                  IF (LIST_TMP(J,1) == LSEND_PP(K,I,N)) GOTO 512
                  IF (LIST_TMP(J,1) >  LSEND_PP(K,I,N)) GOTO 511
                END DO
 511            CONTINUE
                PROC = PROC + 1
                DO M = PROC, J+1, -1
                  LIST_TMP(M,1) = LIST_TMP(M-1,1)
                END DO
                LIST_TMP(J,1) = LSEND_PP(K,I,N)
 512            CONTINUE
              END IF
            END DO
          END DO
        END IF
!
        WRITE(NOUT,*) PROC
        IF (NSEND_P(N)>0) THEN
          DO M=1, PROC
            POSI = 2
            DO I=1, NSEND_P(N)
            JJ = LSEND_P(I,N)
              DO K=1, NBMAXNSHARE
                IF (LSEND_PP(K,I,N)==LIST_TMP(M,1)) THEN
                  J = 1
                  DO WHILE (LRECV_P(J,N) /= JJ)
                    J = J + 1
                  END DO
                  LIST_TMP(M,POSI  ) = J
                  LIST_TMP(M,POSI+1) = JJ
                  J = 1
                  DO WHILE (PART_P(JJ,J) /= N)
                    J = J + 1
                  END DO
                  LIST_TMP(M,POSI+2) = KNOGL(JJ,PART_P(JJ,J))
                  POSI = POSI + 3
                END IF
              END DO
            END DO
            WRITE(NOUT,*) LIST_TMP(M,1)-1, (POSI-1)/3
            WRITE(NOUT,*) (LIST_TMP(M,3*K-1), K=1,(POSI-1)/3)
            WRITE(NOUT,*) (LIST_TMP(M,3*K  ), K=1,(POSI-1)/3)
            WRITE(NOUT,*) (LIST_TMP(M,3*K+1), K=1,(POSI-1)/3)
          END DO
        END IF
        IF (ALLOCATED(LIST_TMP)) DEALLOCATE (LIST_TMP)
!
        CLOSE(NOUT)
      END DO
!
      DEALLOCATE(XSEU1)
      DEALLOCATE(YSEU1)
      DEALLOCATE(ZSEU1)
      DEALLOCATE(XSEU2)
      DEALLOCATE(YSEU2)
      DEALLOCATE(ZSEU2)
      DEALLOCATE(NUM_SEU1)
      DEALLOCATE(NUM_SEU2)
      DEALLOCATE(NUM_SEU1_P)
      DEALLOCATE(NUM_SEU2_P)
      DEALLOCATE(PART_P)
      DEALLOCATE(SEU_P)
      DEALLOCATE(CSEU_P)
      DEALLOCATE(LSEND_P)
      DEALLOCATE(LSEND_PP)
      DEALLOCATE(NRECV_P)
      DEALLOCATE(LRECV_P)
!
      WRITE(LU,*) 'FINISHED DEALING WITH WEIRS'
      ENDIF ! WITH_WEIRS
!
!----------------------------------------------------------------------
!
      DEALLOCATE (IKLE) ! #### MOVED FROM FAR ABOVE
      DEALLOCATE(NPART)
      DEALLOCATE(EPART)
      DEALLOCATE(NPOIN_P)
      DEALLOCATE(NELEM_P)
      DEALLOCATE(NPTFR_P)
      DEALLOCATE(NPTIR_P)
!
      DEALLOCATE(IKLES)
      IF(NPLAN.GT.1) THEN
        DEALLOCATE(IKLES3D)
        DEALLOCATE(IKLES3D_P)
      ENDIF
      DEALLOCATE(IKLES_P)
      DEALLOCATE(IRAND)
      DEALLOCATE(F)
!
      DEALLOCATE(KNOLG)
      DEALLOCATE(KNOGL)
      DEALLOCATE(ELELG)
      DEALLOCATE(KP1BOR)
      DEALLOCATE(VARIABLE)
!
!----------------------------------------------------------------------
!
      IF (TIMECOUNT) THEN
        CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
        TFIN = TEMPS
        WRITE(LU,*) 'OVERALL TIMING: ',
     &    (1.0*(TFIN-TDEB))/(1.0*PARSEC),' SECONDS'
        WRITE(LU,*) ' '
      ENDIF
!
      WRITE(LU,*) '+---- PARTEL: NORMAL TERMINATION ----+'
      WRITE(LU,*) ' '
!
      GO TO 998
!
! Error handling for zones
 303  WRITE(LU,*) 'ERROR WITH ZONE FILE FORMAT'
      GO TO 999
 304  WRITE(LU,*) 'ABNORMAL END OF FILE'
      GO TO 999
 305  WRITE(LU,*) 'ERROR WITH WEIR FILE FORMAT'
      GO TO 999

!
 999  CALL PLANTE(1)
      STOP
!
!----------------------------------------------------------------------
!
998   CONTINUE
      END SUBROUTINE PARTEL
