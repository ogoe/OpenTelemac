/*=========================================================================

  Program:   Visualization Toolkit
  Module:    $RCSfile: vtkSerafinReader.cxx,v $

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

////// Reader for files 2D/3D generated by The  TELEMAC modelling system \\\\\
// Module developped by herve ozdoba - Sept 2008 ( herve-externe.ozdoba at edf.fr / herve at ozdoba.fr )
// Please address all comments to Regina Nebauer ( regina.nebauer at edf.fr )
// >>> Test version

#include "FFileReader.h"
#include "stdSerafinReader.h"
#include "vtkSerafinReader.h"

#include "vtkErrorCode.h"
#include "vtkInformation.h"
#include "vtkInformationVector.h"
#include "vtkStreamingDemandDrivenPipeline.h"
#include "vtkUnstructuredGrid.h"
#include "vtkMultiBlockDataSet.h"
//#include "vtkTemporalDataSet.h"
#include "vtkPointData.h"
#include "vtkCellData.h"
#include "vtkDoubleArray.h"
#include "vtkIntArray.h"
#include "vtkCellArray.h"

#include <iostream>  // use cerr

/** +++++++++++++++++ D√©finition des m√©thodes de la classe FFileReader +++++++++++++++++ **/

/* ******************* Constructeur *******************
 * Ce constructeur re√ßoit un flux de lecture de fichier en argument .
 * Gloabalement, les initialisations sont effectu√©e ici et le premier entier est lu pour
 * d√©terminer dans quelle configuration d'√©criture on se place en association avec le fichier .
 * La diff√©renciation petit/grand boutien est faite √† la lecture du premier entier 
 * qui doit valoir la taille maximale du titre soit 80 caract√®res (√† l'heure o√π j'√©cris ces lignes) .
 */
FFileReader :: FFileReader(ifstream* stream)
{
	// diff√©rentes initialisations
	this->BigEndian  = false ;
	this->BlocSize	 = 0 ;
	this->FileStream = stream;
        this->FloatSize  = sizeof(float);

	// lecture de l'ent√™te
	readBlocSize ();
	if (this->BlocSize != TITLE_MAX_SIZE) // pas d'√©change d'octet √† la lecture
	{
		this->BigEndian = true ;
		// Relecture de l'ent√™te
		readBlocSize ();
        }
        
        FFileReader::readIntArray   = &FFileReader::g_readInt32Array   ;
        FFileReader::readFloatArray = &FFileReader::g_readFloat32Array ;
        /**********
         * need to check the size of float variables somewhere
         * 
         * first float variable is coordinates but class nos nothing about file structure
         * 
         * So need to do this elsewhere but allow to reset the read functions from outside
         ************/ 
};

/* Lecture d'un tableau d'entier arr de taille size avec inversion de octets */
int64_t FFileReader :: s_readInt32Array(int* arr, const int size)
{
	FileStream->read ((char*)(arr), sizeof(int)*size);
	Swap32Array (size, (char*)(arr));
	return FileStream->tellg();
};

/* Lecture d'un tableau d'entier arr de taille size sans inversion de octets */
int64_t FFileReader :: ns_readInt32Array(int* arr, const int size)
{
	FileStream->read ((char*)(arr), sizeof(int)*size);
	return FileStream->tellg();
};

/* Lecture d'un tableau de flottants arr de taille size avec inversion de octets */
int64_t FFileReader :: s_readFloat32Array(float* arr, const int size)
{
	FileStream->read ((char*)(arr), sizeof(float)*size);
	Swap32Array (size, (char*)(arr));
	return FileStream->tellg();
};

/* Lecture d'un tableau de flottants arr de taille size sans inversion de octets */
int64_t FFileReader :: ns_readFloat32Array(float* arr, const int size)
{
	FileStream->read ((char*)(arr), sizeof(float)*size);
	return FileStream->tellg();
};
// generic single entry read functions
int64_t FFileReader :: g_readInt32Array(int* arr, const int size)
{
	FileStream->read ((char*)(arr), sizeof(int)*size);
        if ( this->BigEndian ) {
            Swap32Array (size, (char*)(arr));
        }
	return FileStream->tellg();
};

int64_t FFileReader :: g_readFloat32Array(float* arr, const int size)
{
	FileStream->read ((char*)(arr), sizeof(float)*size);
        if ( this->BigEndian ) {
            Swap32Array (size, (char*)(arr));
        }
	return FileStream->tellg();
};

/* ******************* Destructeur ***************** */
// TODO compl√©ter cette m√©thode !!!
FFileReader :: ~FFileReader()
{
	// Ne rien faire pour le moment
};

/** +++++++++++++++++ D√©finition des m√©thodes de la classe stdSerafinReader +++++++++++++++++ **/

/* ******************* Constructeur ***************** */
stdSerafinReader :: stdSerafinReader(ifstream* stream) : FFileReader(stream)
{
	// TODO Initialisation des variables
	this->metadata  = new SerafinMetaData();
	this->index	= new SerafinIndexInfo();
	
	// Lecture des metadonn√©e
	this->readMetaData ();
	
	//Cr√©ation de l'index
	this->createIndex ();
};

/* ******************* Destructeur ***************** */
// TODO compl√©ter cette m√©thode !!!
//stdSerafinReader :: ~stdSerafinReader()
//{
//	// Ne rien faire pour le moment, provoque une 'legere fuite memoire' maitrisee
//};

/* ******************* createIndex ***************** */
/* Cette m√©thode cr√©e un index de taille et de position √† partir des informations meta 
 * afin de faciliter la lecture du fichier serafin .
 */
void stdSerafinReader :: createIndex ()
{
	int testVolFin = 0 ;
	
	this->index->FileSize = GetFileSize();
	this->index->MetaSize = FileStream->tellg();	
	
	// Taille du fichier - taille des m√©tadonn√©es - IPOB0 - IKLE - table de X - table de Y
	this->index->DataSize 		= (index->FileSize) - (index->MetaSize) - 3 * (4*GetNumberOfNodes()+8) - (4*GetNodeByElements()*GetNumberOfElement()+8);	
	this->index->DataPosision 	= (index->FileSize) - (index->DataSize);
	
	/*............................................................................................*/
	
	// Nombre de variables * nombre de points si le fichier est  en ElFin
	// Nombre de variables * nombre d'√©l√©ments si le fichier est en VolFin 

	if (!Is3Dfile ()) 	FileStream->seekg( this->index->DataPosision + 12				, std::ios_base::beg ); 
	else 			FileStream->seekg( this->index->DataPosision + 12 + (8+GetNumberOfNodes()*4)	, std::ios_base::beg );
	//[ci dessus] Si c'est en 3D, on zappe les valeurs de Z pour obetnir la taille d'un bloc de donn√©es de discr√©tisation
		
	(*this.*readIntArray)(&testVolFin, 1);
	
	if	(GetNumberOfNodes()*4 == testVolFin) 	// Si c'est un fichier ElFin
	{
		this->index->discretizationtype = P0_Elem;
		this->index->DataBlocSize 	= GetNumberOfVars()*(8 + GetNumberOfNodes() * 4) + 12 ;
		
	}
	else if	(GetNumberOfElement()*4 == testVolFin) // Si c'est un fichier Volfin
	{
		this->index->discretizationtype = P1_Elem;
		
		// TODO A supprimer, pas de fichier volfin en 3D !!!!!!!!!!
		this->index->DataBlocSize 	= (!Is3Dfile ()) 	
			?  GetNumberOfVars()    * (8 + GetNumberOfElement() * 4) + 12 
			: (GetNumberOfVars()-1) * (8 + GetNumberOfElement() * 4) + 12 + (8 + GetNumberOfNodes() * 4) ;
	}
	else return;
	
	this->index->ConnectivityPosition	= this->index->MetaSize;
	this->index->XPosition 			= (index->MetaSize) +     (4*GetNumberOfNodes()+8) + (4*GetNodeByElements()*GetNumberOfElement()+8);
	this->index->YPosition 			= (index->MetaSize) + 2 * (4*GetNumberOfNodes()+8) + (4*GetNodeByElements()*GetNumberOfElement()+8);
	
	this->index->NumberOfDate 		= (index->DataSize)/(index->DataBlocSize);
	
};

/* ******************* readMetaData ***************** */
/* Cette methode permet de de lire les m√©tadata dans le but de recueillir les informations
 * essentielles incluses dans le fichier . Globalement, la demarche sequentielle est la suivante :
 * 	-  lecture du titre et suppression des espaces en fin de chaine s'il y en a 
 * 	-  lecture du nombre de variables
 * 	-  lecture du nom des variables et des leurs unit√©s respectives
 * 	-  lecture des paramam√®tres
 *	-  lecture des informations de discr√©tisation
 */
int stdSerafinReader :: readMetaData ()
{
	
	//Lecture du titre
	if (ReadString(metadata->Title, TITLE_MAX_SIZE) != 88) return 0;// metadata->Title[TITLE_MAX_SIZE]='\0';
	DeleteBlank(metadata->Title, TITLE_MAX_SIZE-8);
	
	//lecture du nombre de variables (on passe les entete)
	skipReadingHeader(FileStream);   //skip reclen
        // read linear varsno 
	if ((*this.*readIntArray)(&(metadata->VarNumber), 1) != 96) return 0;
	skipReadingHeader(FileStream);  // skip quad varno
        skipReadingHeader(FileStream);  // skip reclen
	
	//lecture des variables
	// TODO recommencer les contr√¥les de position √† partir d'ici
//         cerr << "NoVarlist " <<  metadata->VarNumber << endl ;
	metadata->VarList = (char *)new SerafinVar[metadata->VarNumber];
	metadata->nVarList = new SerafinVar[metadata->VarNumber];
        
        cerr << "nVarList Size " << sizeof(metadata->nVarList);
        
	{
		int compteur = 0 ;
                char buffer[VAR_DESC_SIZE*2];
		for( compteur; compteur < metadata->VarNumber ; compteur++) {
//  			ReadString(metadata->VarList+compteur*VAR_DESC_SIZE*2, VAR_DESC_SIZE*2);
                        // must read full buffer as each varaible is a file record 
  			ReadString(&buffer[0], VAR_DESC_SIZE*2);
  			strncpy(metadata->nVarList[compteur].name, &buffer[0], VAR_DESC_SIZE);
  			strncpy(metadata->nVarList[compteur].unit, &buffer[VAR_DESC_SIZE], VAR_DESC_SIZE);
                        metadata->nVarList[compteur].name[15]=0;
                        metadata->nVarList[compteur].unit[15]=0;
                        cerr << "VarList Items " << metadata->nVarList[compteur].name << "\n";
                        cerr << "VarList Items " << metadata->nVarList[compteur].unit << "\n";
                }
	};
        cerr << "\n";

	// Lecture des parametres et, si necessaire, de la date de simu
	skipReadingHeader(FileStream);
	(*this.*readIntArray)(metadata->IParam, PARAM_NUMBER);
	skipReadingHeader(FileStream);
	
	if (metadata->IParam[9] == 1)// Si la date est indiqu√©e
	{
		skipReadingHeader(FileStream);
		(*this.*readIntArray)(metadata->Date, DATE_NUMBER);
		skipReadingHeader(FileStream);
	};
        
	//lecture des information de discrietisation
	skipReadingHeader(FileStream);
	(*this.*readIntArray)(metadata->DiscretizationInfo, DISC_DESC_SIZE);
	skipReadingHeader(FileStream);
	
	// On lit l'entete du bloc de lecture pour connaitre la taille de la table de connectivite
	if (IsBigEndian()) s_readBlocSize ();else  ns_readBlocSize ();
        
	
	return FileStream->tellg();
};

/** +++++++++++++++++ D√©finition des m√©thodes de la classe vtkSerafinReader +++++++++++++++++ **/

#include "vtkObjectFactory.h"

//vtkCxxRevisionMacro(vtkSerafinReader, "$Revision: 0.2 $");
vtkStandardNewMacro(vtkSerafinReader);

vtkSerafinReader::vtkSerafinReader()
{
	
	vtkDebugMacro( << "Instanciation du lecteur Serafin");

	this->FileName               = NULL;
	this->FileStream             = NULL;
	this->Reader		    	= NULL;
	this->TimeStep		= 0;

	this->SetNumberOfInputPorts(0);
};

vtkSerafinReader::~vtkSerafinReader()
{
	if (this->FileName)
	{
		this->SetFileName(0);
	}
}

void vtkSerafinReader::SetTimeUnit(int value) 
{
    
    cerr << "TimeUnit " << value << endl;
    
//     // seconds
//     if (value==1)      { this->timefactor=1.0 };
//     // hours
//     else if (value==2) { this->timefactor=3600.0 };
//     // days
//     else if (value==3) { this->timefactor=24*3600.0 };
//     // years
//     else if (value==4) { this->timefactor=24*3600.0 };
    
    
    
}

int vtkSerafinReader::RequestInformation(vtkInformation *vtkNotUsed(request),
					 vtkInformationVector **vtkNotUsed(inputVector),
					 vtkInformationVector *outputVector)
{	
	vtkInformation* outInfo = outputVector->GetInformationObject(0);
	//outInfo->Set(vtkStreamingDemandDrivenPipeline::MAXIMUM_NUMBER_OF_PIECES(),1);

	if ( !this->FileName )
	{
		vtkErrorMacro("No filename specified");
		return 0;
	}

	this->FileStream = new ifstream(this->FileName, ifstream::binary|ifstream::in);

	if (this->FileStream->fail())
	{
		this->SetErrorCode(vtkErrorCode::FileNotFoundError);
		delete this->FileStream;
		this->FileStream = NULL;
		vtkErrorMacro("Specified filename not found");
		return 0;
	}

	this->Reader	 = new stdSerafinReader( FileStream);
	
	{//Gestion du temps
		const int totime = this->Reader->GetTotalTime();
		if (totime > 1)
		{
			int i=0;
			double TimeValues[totime];
			
			for (i=0; i<totime ;i++) {TimeValues[i] = this->Reader->GetTime(i) ;}
			
			outInfo->Set(vtkStreamingDemandDrivenPipeline::TIME_STEPS(), &TimeValues[0],  totime);
			
			double timeRange[2];
			timeRange[0] = TimeValues[0];
			timeRange[1] = TimeValues[totime-1];
			outInfo->Set(vtkStreamingDemandDrivenPipeline::TIME_RANGE(),  timeRange, 2);
			
		};
      }


	return 1;
}

int vtkSerafinReader::RequestData(vtkInformation *vtkNotUsed(request),
				  vtkInformationVector **vtkNotUsed(inputVector),
				  vtkInformationVector *outputVector)
{
	/*double ActualTimeValue = 0.0;
	
	vtkInformation *outInfo = outputVector->GetInformationObject(0);
	vtkMultiBlockDataSet *output = vtkMultiBlockDataSet::SafeDownCast(outInfo->Get(vtkDataObject::DATA_OBJECT()));
	int tsLength = outInfo->Length(vtkStreamingDemandDrivenPipeline::TIME_STEPS());
	double* steps =   outInfo->Get(vtkStreamingDemandDrivenPipeline::TIME_STEPS());
    


	// Check if a particular time was requested by the pipeline.
	// This overrides the ivar.
	if(outInfo->Has(vtkStreamingDemandDrivenPipeline::UPDATE_TIME_STEPS()) && tsLength>0)
	{
		// Get the requested time step. We only support requests of a single time
		// step in this reader right now
		double *requestedTimeSteps = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_TIME_STEPS());
	    
		// find the first time value larger than requested time value
		// this logic could be improved
		int cnt = 0;
		while (cnt < tsLength-1 && steps[cnt] < requestedTimeSteps[0])
		{
			cnt++;
		}
		
		ActualTimeValue = steps[cnt];
	}*/
	
	int totime = this->Reader->GetTotalTime();
	vtkInformation 		*outInfo = outputVector->GetInformationObject(0);	
	vtkUnstructuredGrid 	*output = vtkUnstructuredGrid::SafeDownCast(outInfo->Get(vtkDataObject::DATA_OBJECT()));
	int tsLength = outInfo->Length(vtkStreamingDemandDrivenPipeline::TIME_STEPS());
	double *steps =   outInfo->Get(vtkStreamingDemandDrivenPipeline::TIME_STEPS());
        double requestedTimeSteps = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_TIME_STEP());

	if(outInfo->Has(vtkStreamingDemandDrivenPipeline::UPDATE_TIME_STEP()) && tsLength>0)
	{
		// Get the requested time step. We only support requests of a single time
		// step in this reader right now
		double requestedTimeSteps = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_TIME_STEP());
	    
		// find the first time value larger than requested time value
		// this logic could be improved
		int cnt = 0;
		while (cnt < tsLength-1 && steps[cnt] < requestedTimeSteps)
		{
			cnt++;
		}
		
		this->TimeStep = cnt;
	}
        
        vtkDebugMacro( << "Serafin steps <" << steps << ">..." << requestedTimeSteps << this->TimeStep);
	
	if ( outInfo->Has( vtkStreamingDemandDrivenPipeline::UPDATE_TIME_STEP() ) )
	{
		double* steps = outInfo->Get( vtkStreamingDemandDrivenPipeline::TIME_STEPS() );
//		output->GetInformation()->Set( vtkDataObject::DATA_TIME_STEP(), steps+this->TimeStep, 1 );
		//output->GetInformation()->Set( vtkDataObject::DATA_TIME_STEP(), steps);
	};


	if ( this->FileStream == NULL )
	{
		return 0;
	}
	
	this->ReadFile(output, this->TimeStep);

	return 1;
}

void vtkSerafinReader::PrintSelf(ostream& os, vtkIndent indent)
{
  this->Superclass::PrintSelf(os,indent);

  os << indent << "File Name: "       		<< (this->FileName ? this->FileName : "(none)") << endl;
  os << indent << "Number Of Nodes: " 		<< this->Reader->GetNumberOfNodes()		<< endl;
  os << indent << "Number Of Node Fields: "     << this->Reader->GetNumberOfVars() 		<< endl;
  os << indent << "Number Of Cells: " 		<< this->Reader->GetNumberOfElement() 		<< endl;
}

void vtkSerafinReader::ReadFile(vtkUnstructuredGrid *output, int time)
{
	output->Reset();
        
        cerr << "Reading Time " << time << endl;
	
	// Lecture de la geometrie
	this->ReadGeometry(output,  time);
	
	// Lecture des donnees
	this->ReadData(output,  time);
	
	return;
}

void vtkSerafinReader::ReadGeometry(vtkUnstructuredGrid *output, int time)
{
	vtkFloatArray *coords = vtkFloatArray::New();
	coords->SetNumberOfComponents(3);
	coords->SetNumberOfTuples(this->Reader->GetNumberOfNodes());
	
	this->Reader->WriteCoord(coords->GetPointer (0), time);
	
	//Lecture de la table de connectivite
	{
		int i = 0, k = 0, l = 0;
		vtkIdType list[27];
		const int size = this->Reader->GetNodeByElements()*this->Reader->GetNumberOfElement();
		int* arr = new int[size];
		
		switch(this->Reader->GetNodeByElements())
		{
			case 3 : l = VTK_TRIANGLE ; break;
			case 4 : l = (this->Reader->Is3Dfile())? VTK_TETRA : VTK_QUAD ;	break;
			case 5 : l = VTK_PYRAMID; break;
			case 6 : l = VTK_WEDGE;	break;
			case 8 : l = VTK_HEXAHEDRON ;break;
			default:
			{
				vtkErrorMacro( << "cell type is not supported\n");return;
			}				
		}
		
		this->Reader->WriteConnectivity(arr);		
		output->Allocate(this->Reader->GetNumberOfNodes(), this->Reader->GetNumberOfNodes());
		
		for(i = 0; i < this->Reader->GetNumberOfElement(); i++)
		{
			for(k = 0; k < this->Reader->GetNodeByElements(); k++)
				list[k] = arr[this->Reader->GetNodeByElements()*i+k]-1;

			output->InsertNextCell(l, this->Reader->GetNodeByElements(), list);
		};
		
		delete[] arr;
	};
	
	
	
	vtkPoints *points = vtkPoints::New();
	points->SetData(coords);
	coords->Delete();
  
	output->SetPoints(points);
	points->Delete();

}

void vtkSerafinReader::ReadData(vtkUnstructuredGrid *output, int time)
{
	int i = 0, dim = 1;int vel =0 ;
	char name[VAR_DESC_SIZE+1];
	
	int sveldim = this->Reader->getSVelDim();
	int veldim = this->Reader->getVelDim()-sveldim;
        
	const int size = this->Reader->GetNumberOfNodes();
	
	//const int ideb = (this->Reader->Is3Dfile ()) ? 1 : 0;
        // jmf
        const int ideb = 0;
	const int ifin = this->Reader->GetNumberOfVars();
        
	for (i = ideb ; i<ifin ; i++)
	{
		vtkFloatArray *data = vtkFloatArray::New();
		
		this->Reader->GetVarNameById(i, name);
                
                cerr << "ReadData varname" << i << name << '\n';

		
		if ((strstr ( name, "VELOCITY") != NULL|| strstr ( name, "VITESSE") != NULL) 
                  && strstr ( name, "SCALAR VELOCITY") == NULL   
                  && strstr ( name, "VITESSE SCALAIRE") == NULL ) 
		{
                        // Changing name to remove _U _V _W
                        if (strstr ( name, "VELOCITY") != NULL)
                           strcpy(name,"VELOCITY");
                        else
                           strcpy(name,"VITESSE");
			data->SetName(name);
			data->SetNumberOfComponents(3);
			
 			if (strstr ( name, "SHEAR VELOCITY") != NULL) 
			{
				data->SetNumberOfTuples(size);
				{//Stockage des donnÈes
					this->Reader->GetVarRangeValues(size, sveldim, i, data->GetPointer (0), time);
				};
				i+= (sveldim-1);
				
			}else{
				data->SetNumberOfTuples(size);
				{//Stockage des donnÈes
					this->Reader->GetVarRangeValues(size, veldim, i, data->GetPointer (0), time);
				};
				i+= (veldim-1);
				
			}
                        output->GetPointData()->SetVectors(data);
			
		} else {
			data->SetName(name);			
			data->SetNumberOfComponents(1);		
			data->SetNumberOfTuples(this->Reader->GetNumberOfNodes());
			
			{//Stockage des donnÈes
				this->Reader->GetVarValues(time, i, 0, data->GetPointer (0), size);
			};
                        output->GetPointData()->AddArray(data);
		}
		
// 		if (!output->GetPointData()->GetVectors()) {  // checking that vectors have not been loaded
//                         output->GetPointData()->SetVectors(data);
		
		data->Delete();
		
	}
}



