      MODULE M_MED
!***********************************************************************
! THIS FILE IS PART OF BIEF
! COPYRIGHT (C) EDF 2008
!-----------------------------------------------------------------------
!
! MODULE : M_MED
!
! AUTHORS:
!   - JULIEN HOLLEVILLE
! DATE :
!   - 04.2008
!-----------------------------------------------------------------------
!
! NOTE THAT THIS INTERFACE IS FOR THE LIBRARY INCLUDED IN MEDV2.3.6
! CHANGES MIGHT BE REQUIRED WITH FUTURE VERSIONS OF MED.
!
! FOR MORE INFORMATION: HTTP://WWW.CODE-ASTER.ORG/OUTILS/MED/
!-----------------------------------------------------------------------

      IMPLICIT NONE
      
      ! PLACE PUBLIC DECLARATIONS HERE ...

      PUBLIC OPEN_FILE_MED
      PUBLIC CLOSE_FILE_MED
      PUBLIC WRITE_MESH_MED
      PUBLIC CREATE_DATASET_MED
      PUBLIC WRITE_DATA_MED
      PUBLIC SUITE_MED

!-----------------------------------------------------------------------
!   DECLARATIONS DES VARIABLES MED
!-----------------------------------------------------------------------

!     INCLUDE 'med.hf'

      INTEGER MED_FULL_INTERLACE,MED_NO_INTERLACE
      INTEGER MED_NO_PFLMOD, MED_GLOBAL, MED_COMPACT
      INTEGER MED_LECTURE,MED_LECTURE_ECRITURE
      INTEGER MED_LECTURE_AJOUT,MED_CREATION
      INTEGER MED_NON_STRUCTURE, MED_STRUCTURE
      INTEGER MED_GRILLE_CARTESIENNE, MED_GRILLE_POLAIRE
      INTEGER MED_GRILLE_STANDARD
      INTEGER MED_MAILLE, MED_FACE, MED_ARETE, MED_NOEUD
      INTEGER MED_NOEUD_MAILLE,MED_NOEUD_FACE,MED_NOEUD_ARETE
      INTEGER MED_COOR, MED_CONN, MED_NOM, MED_NUM, MED_FAM
      INTEGER MED_COOR_IND1,MED_COOR_IND2,MED_COOR_IND3 
      INTEGER MED_INT32, MED_INT64,MED_FLOAT64,MED_INT
      INTEGER MED_POINT1,MED_SEG2,MED_SEG3,MED_TRIA3,MED_TRIA6
      INTEGER MED_QUAD4,MED_QUAD8,MED_TETRA4,MED_TETRA10,MED_HEXA8
      INTEGER MED_HEXA20,MED_PENTA6,MED_PENTA15,MED_PYRA5,MED_PYRA13 
      INTEGER MED_POLYGONE, MED_POLYEDRE, MED_NONE
      INTEGER MED_NOD, MED_DESC
      INTEGER MED_CART, MED_CYL, MED_SPHER
      LOGICAL MED_FAUX, MED_VRAI
      INTEGER MED_GROUPE, MED_ATTR
      INTEGER MED_COMP, MED_DTYPE
      INTEGER MED_HDF_VERSION, MED_VERSION,MED_FICH_DES
      INTEGER MED_NOPG, MED_NOPF,MED_NOPDT
      INTEGER MED_NONOR,MED_DIM1,MED_ALL
      CHARACTER*32 MED_NOPFL,MED_NOGAUSS, MED_NOREF
      CHARACTER*32 MED_GAUSS_ELNO

      PARAMETER (MED_MAILLE=0,MED_FACE=1,MED_ARETE=2,MED_NOEUD=3)
      PARAMETER (MED_NOEUD_MAILLE=4)
      PARAMETER (MED_FULL_INTERLACE=0, MED_NO_INTERLACE=1)
      PARAMETER (MED_NO_PFLMOD=0, MED_GLOBAL=1, MED_COMPACT=2)
      PARAMETER (MED_LECTURE=0,MED_LECTURE_ECRITURE=1)
      PARAMETER (MED_LECTURE_AJOUT=2,MED_CREATION=3)
      PARAMETER (MED_NON_STRUCTURE=0,MED_STRUCTURE=1)
      PARAMETER (MED_GRILLE_CARTESIENNE=0,MED_GRILLE_POLAIRE=1)
      PARAMETER (MED_GRILLE_STANDARD=2)
      PARAMETER (MED_COOR=0,MED_CONN=1,MED_NOM=2,MED_NUM=3,MED_FAM=4)
      PARAMETER (MED_COOR_IND1=5,MED_COOR_IND2=6,MED_COOR_IND3=7)
      PARAMETER (MED_INT32=24, MED_INT64=26,MED_FLOAT64=6,MED_INT=28)
      PARAMETER (MED_POINT1=1,MED_SEG2=102,MED_SEG3=103,MED_TRIA3=203)
      PARAMETER (MED_TRIA6=206,MED_QUAD4=204,MED_QUAD8=208)
      PARAMETER (MED_TETRA4=304,MED_TETRA10=310,MED_HEXA8=308)
      PARAMETER (MED_HEXA20=320,MED_PENTA6=306)
      PARAMETER (MED_PENTA15=315,MED_PYRA5=305,MED_PYRA13=313)
      PARAMETER (MED_POLYGONE = 400, MED_POLYEDRE = 500, MED_NONE=0)
      PARAMETER (MED_NOD=0, MED_DESC=1)
      PARAMETER (MED_CART=0,MED_CYL=1, MED_SPHER=2)
      PARAMETER (MED_FAUX=.FALSE.,MED_VRAI=.TRUE.)
      PARAMETER (MED_GROUPE=0, MED_ATTR=1)
      PARAMETER (MED_COMP=0, MED_DTYPE=1)
      PARAMETER (MED_HDF_VERSION=0, MED_VERSION=1,MED_FICH_DES=2)
      PARAMETER (MED_NOPG = 1, MED_NOPF = 0)
      PARAMETER (MED_NOPDT = -1, MED_NONOR = -1, MED_DIM1 = 1)
      PARAMETER (MED_ALL = 0)
      PARAMETER (MED_NOPFL='                                ')
      PARAMETER (MED_NOGAUSS='                                ')
      PARAMETER (MED_NOREF='                                ')
      PARAMETER (MED_GAUSS_ELNO='MED_GAUSS_ELNO                  ')

      INTEGER MED_NBR_GEOMETRIE_MAILLE
      INTEGER MED_NBR_GEOMETRIE_FACE
      INTEGER MED_NBR_GEOMETRIE_ARETE
      PARAMETER (MED_NBR_GEOMETRIE_MAILLE=15,MED_NBR_GEOMETRIE_FACE=4)
      PARAMETER (MED_NBR_GEOMETRIE_ARETE = 2)

      INTEGER MED_MAILLAGE
      INTEGER MED_CHAMP
      PARAMETER (MED_MAILLAGE= 0)
      PARAMETER (MED_CHAMP= 1)

!-----------------------------------------------------------------------
!   INTERFACE MED
!-----------------------------------------------------------------------
!
!
!-----------------------------------------------------------------------
!   INTERFACE MED
!-----------------------------------------------------------------------

      INTERFACE
    
!   INTERFACE MED FICHIER

! CETTE ROUTINE PERMET DE TESTER SI UN FICHIER EST AU FORMAT HDF V5
      SUBROUTINE EFFOCO(NOM,CRET)
        IMPLICIT NONE
        INTEGER CRET
        CHARACTER*(*) NOM
      END SUBROUTINE EFFOCO
    
! CETTE ROUTINE PERMET DE FERMER UN FICHIER MED
      SUBROUTINE EFFERM (FID,CRET)
        IMPLICIT NONE
        INTEGER FID,CRET
      END SUBROUTINE EFFERM

! CETTE ROUTINE PERMET D'ASSOCIER UNE DESCRIPTION A UN FICHIER :
! LA DESCRIPTION EST ECRITE DANS LE FICHIER
      SUBROUTINE EFFIDE (FID,DES,CRET)
        IMPLICIT NONE
        INTEGER FID,CRET
        CHARACTER*(*) DES
      END SUBROUTINE EFFIDE

! CETTE ROUTINE PERMET DE LIRE DANS UN FICHIER MED EXISTANT SELON LES
! PARAMETRES UTILISES 
      SUBROUTINE EFFIEN (FID,QUOI,STR,CRET)
        IMPLICIT NONE
        INTEGER FID,QUOI,CRET
        CHARACTER*(*) STR
      END SUBROUTINE EFFIEN

! RETOURNE LA LONGUEUR DE LA DESCRIPTION ASSOCIEE A UN FICHIER MED SI
! CETTE DESCRIPTION EXISTE
      SUBROUTINE EFLFDE (FID,LON,CRET)
        IMPLICIT NONE
        INTEGER FID,CRET,LON
      END SUBROUTINE EFLFDE

! CETTE ROUTINE PERMET DE CREER OU D'OUVRIR UN FICHIER AU FORMAT MED
! SELON LE MODE D'ACCES SOUHAITE
      SUBROUTINE EFOUVR(FID, NOM, ACCES, CRET)
        IMPLICIT NONE
        CHARACTER *(*) NOM
        INTEGER ACCES, FID, CRET
      END SUBROUTINE EFOUVR

! CETTE ROUTINE PERMET DE TESTER SI UN FICHIER QUE L'ON VEUT LIRE A ETE
! CREE AVEC LA MEME VERSION DE LA BIBLIOTHEQUE MED QUE CELLE UTILISEE
! POUR LIRE CE FICHIER
      SUBROUTINE EFVECO(NOM, CRET)
        IMPLICIT NONE
        INTEGER CRET
        CHARACTER* (*) NOM
      END SUBROUTINE EFVECO

! CETTE ROUTINE RENVOIE LES ENTIERS COMPOSANT LE NUMERO DE VERSION DE LA
! BIBLIOTHEQUE 
      SUBROUTINE EFVEDO(MAJ,MIN,REL,CRET)
        IMPLICIT NONE
        INTEGER MAJ,MIN,REL,CRET
      END SUBROUTINE EFVEDO
    
! CETTE ROUTINE DONNE LES ENTIERS COMPOSANT LE NUMERO DE VERSION DE LA
! BIBLIOTHEQUE MED-FICHIER QUI A ETE UTILISEE POUR CREER LE FICHIER
! AUQUEL ON ACCEDE VIE L'ID FID
      SUBROUTINE EFVELI(FID,MAJ,MIN,REL, CRET)
        IMPLICIT NONE
        INTEGER FID,MAJ,MIN,REL,CRET
      END SUBROUTINE EFVELI
    
! CETTE ROUTINE PERMET DE MONTER LE CONTENU D'UN FICHIER MED
! (SOIT LES MAILLAGES, SOIT LES CHAMPS) DANS LE FICHIER MED COURANT
      SUBROUTINE EFMONT(FID,ACCES,TYPE1,MID,CRET)
        IMPLICIT NONE
        INTEGER CRET,FID,MID,TYPE1
        CHARACTER* (*) ACCES
      END SUBROUTINE EFMONT

! CETTE ROUTINE PERMET DESACTIVER UN POINT DE MONTAGE
      SUBROUTINE EFDEMO(FID,MID,TYPE1,CRET)
        IMPLICIT NONE
        INTEGER CRET,FID,MID,TYPE1
      END SUBROUTINE EFDEMO

!   INTERFACE MED MAILLAGE

! LECTURE DE LA DIMENSION DU MAILLAGE DONT LE NOM EST PASSE EN PARAMETRE
      SUBROUTINE EFDIML( FID , MAA, DIM, CRET)
        IMPLICIT NONE
        INTEGER FID,DIM,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFDIML
    
! ECRITURE DE LA DIMENSION DE L'ESPACE DU DOMAINE DE CALCUL ASSOCIE
! AU MAILLAGE
      SUBROUTINE EFESPC( FID , MAA, DIM, CRET)
        IMPLICIT NONE
        INTEGER FID,DIM,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFESPC
    
! LECTURE DE LA DIMENSION DE L'ESPACE DU DOMAINE DE CALCUL ASSOCIE AU
! MAILLAGE
      SUBROUTINE EFESPL( FID , MAA, DIM, CRET)
        IMPLICIT NONE
        INTEGER FID,DIM,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFESPL
     
! CREATION D'UN MAILLAGE DANS UN FICHIER MED DONT ON CONNAIT LE NOM,
! LA DIMENSION ET LE TYPE
      SUBROUTINE EFMAAC ( FID , NOM , DIM , TYPE1, DESC, CRET )
        IMPLICIT NONE
        CHARACTER *(*) NOM
        CHARACTER *(*) DESC
        INTEGER FID, DIM, TYPE1, CRET
      END SUBROUTINE EFMAAC

! CETTE ROUTINE LIT LES ATTRIBUTS DE BASE OBLIGATOIREMENT ASSOCIES 
!A UN MAILLAGE 

      SUBROUTINE EFMAAI( FID , INDICE , MAA , DIM , TYPE1, DESC, CRET)
        IMPLICIT NONE
        INTEGER FID,DIM,CRET,INDICE,TYPE1
        CHARACTER *(*) MAA
        CHARACTER *(*) DESC
      END SUBROUTINE EFMAAI
    
! ECRITURE DU TYPE D'UNE GRILLE (MAILLAGE STRUCTURE). 
      SUBROUTINE EFNAGE( FID,MAA,TYPE1,CRET)
        IMPLICIT NONE
        INTEGER FID,TYPE1,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFNAGE
    
! LECTURE DU TYPE D'UNE GRILLE (MAILLAGE STRUCTURE). 
      SUBROUTINE EFNAGL( FID,MAA,TYPE1,CRET)
        IMPLICIT NONE
        INTEGER FID,TYPE1,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFNAGL
     
! ECRITURE DE L'ATTRIBUT DE MAILLAGE "NOMBRE DE NOEUDS ISOLES". 
      SUBROUTINE EFNNIE (FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER*(*) MAA
      END SUBROUTINE EFNNIE
    
! LECTURE DE L'ATTRIBUT DE MAILLAGE "NOMBRE DE NOEUDS ISOLES"
      SUBROUTINE EFNISL (FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER*(*) MAA
      END SUBROUTINE EFNISL
    
! ECRITURE DE L'ATTRIBUT DE MAILLAGE
! "NOMBRE DE NOEUDS MAXIMUM PAR MAILLE"
      SUBROUTINE EFNNME (FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER*(*) MAA
      END SUBROUTINE EFNNME
    
! LECTURE DE L'ATTRIBUT DE MAILLAGE
! "NOMBRE DE NOEUDS MAXIMUM PAR MAILLE".
      SUBROUTINE EFNNML (FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER*(*) MAA
      END SUBROUTINE EFNNML
  
! ECRITURE DE L'ATTRIBUT DE MAILLAGE "NOMBRE DE NOEUDS SOMMETS"
      SUBROUTINE EFNNSE (FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER*(*) MAA
      END SUBROUTINE EFNNSE
    
! LECTURE DE L'ATTRIBUT DE MAILLAGE "NOMBRE DE NOEUDS SOMMETS"
      SUBROUTINE EFNNSL (FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER*(*) MAA
      END SUBROUTINE EFNNSL
    
! CETTE ROUTINE RENVOIE LE NOMBRE DE MAILLAGE (EVENTUELLEMENT 0)
! CONTENU DANS LE FICHIER MED DONT LE DESCRIPTEUR EST PASSE EN PARAMETRE
      SUBROUTINE EFNMAA( FID , N , CRET)
        IMPLICIT NONE
        INTEGER FID, N, CRET
      END SUBROUTINE EFNMAA
    
! CREE UN NOM DE MAILLAGE UNIVERSEL (UNIQUE) DE MANIERE AUTOMATIQUE DANS
! LE FICHIER MED
      SUBROUTINE EFUNVC ( FID , MAA , CRET )
        IMPLICIT NONE
        CHARACTER *(*) MAA
        INTEGER FID, CRET
      END SUBROUTINE EFUNVC
     
! LECTURE DU NOM UNIVERSEL QUI CORRESPOND A UNE CHAINE DE
! MED_TAILLE_LNOM (80) CARACTERES
      SUBROUTINE EFUNVL( FID , NOM , NOMU , CRET)
        IMPLICIT NONE
        INTEGER FID,CRET
        CHARACTER *(*) NOM,NOMU
      END SUBROUTINE EFUNVL


!   INTERFACE MED ENTITE
  
! ECRITURE DES CONNECTIVITES DES ELEMENTS (MAILLES/FACES/ARETES) D'UN
! MAILLAGE NON STRUCTURE
      SUBROUTINE EFCONE(FID,MAA,MDIM,CON,MODSWT,N,TYPENT,TYPGEO,TYPCON,
     *                  CRET)
       IMPLICIT NONE
        CHARACTER*(*) MAA
        INTEGER FID, CON(*),TYPENT,TYPGEO,TYPCON,CRET
        INTEGER N,MDIM, MODSWT
      END SUBROUTINE EFCONE

! LECTURE DES CONNECTIVITES DES ELEMENTS (MAILLES/FACES/ARETES)
! D'UN MAILLAGE NON STRUCTURE
      SUBROUTINE EFCONL(FID,MAA,MDIM,CONN,MODSWT,PFLTAB,PSIZE,TYPENT,
     *                  TYPGEO,TYPCON,CRET)
        IMPLICIT NONE
        CHARACTER*(*) MAA
        INTEGER MDIM
        INTEGER FID, CONN(*),TYPENT,TYPGEO,TYPCON,CRET
        INTEGER PFLTAB(*), PSIZE
        INTEGER MODSWT
      END SUBROUTINE EFCONL
    
! ECRITURE DES COORDONNEES DES NOEUDS D'UN MAILLAGE NON STRUCTURE OU
! D'UN MAILLAGE STRUCTURE DE TYPE MED_GRILLE_STANDARD
      SUBROUTINE EFCOOE(FID,MAA,MDIM,COO,MODSWT,N,TYPREP,NOM,UNIT,CRET)
        IMPLICIT NONE
        CHARACTER *(*) MAA
        DOUBLE PRECISION COO(*)
        INTEGER FID,TYPREP,MDIM
        INTEGER N,CRET,MODSWT
        CHARACTER *(*) NOM(*), UNIT(*)
      END SUBROUTINE EFCOOE

! LECTURE DES COORDONNEES DES NOEUDS D'UN MAILLAGE NON STRUCTURE OU D'UN
! MAILLAGE STRUCTURE CORRESPONDANT A UNE GRILLE MED_GRILLE_STANDARD
      SUBROUTINE EFCOOL(FID,MAA,MDIM,COO,MODSWT,NUMCO,PFLTAB,PSIZE,
     *                  TYPREP,NOM,UNIT,CRET)
        IMPLICIT NONE
        INTEGER FID
        CHARACTER*(*) MAA
        INTEGER MDIM
        DOUBLE PRECISION COO(*)
        INTEGER MODSWT,NUMCO
        INTEGER PFLTAB(*),PSIZE
        INTEGER TYPREP
        CHARACTER*(*) NOM(*), UNIT(*)
        INTEGER CRET
      END SUBROUTINE EFCOOL

c$$$      SUBROUTINE efcool(fid,maa,mdim,coo,modswt,numco,pfltab,psize,
c$$$     *typrep,nom,unit,cret)
c$$$        CHARACTER *(*) maa
c$$$        REAL*8 coo(*)
c$$$        INTEGER mdim
c$$$        INTEGER fid,typrep,n,cret,modswt
c$$$        INTEGER pfltab(*),psize, numco
c$$$        CHARACTER *(*) nom(*), unit(*)
c$$$      END SUBROUTINE efcool
      
! ECRITURE GLOBALE DES ATTRIBUTS INTERNES DES ELEMENTS
! (MAILLES/FACES/ARETES) D'UN MAILLAGE
      SUBROUTINE EFELEE(FID,MAA,MDIM,CON,TYPSWT,NOM,INOM,NUM,INUM,FAM,N,
     *                  TYPENT,TYPGEO,TYPCON,CRET)
        IMPLICIT NONE
        INTEGER FID,MDIM,N,CRET
        INTEGER CON(*),FAM(*),NUM(*)
        INTEGER TYPGEO,TYPENT,TYPCON,TYPSWT
        CHARACTER*(*) NOM,MAA
        LOGICAL INOM,INUM
      END SUBROUTINE EFELEE

! LECTURE GLOBALE DES ATTRIBUTS DES MAILLES/FACES/ARETES D'UN MAILLAGE
      SUBROUTINE EFELEL(FID,MAA,MDIM,CONN,MODSWT,NOM,INOM,NUM,INUM,FAM,
     *                  N,TYPENT,TYPGEO,TYPCON,CRET)
        IMPLICIT NONE
        INTEGER FID,MDIM,N,CRET,MODSWT
        INTEGER TYPGEO,TYPENT,TYPCON
        INTEGER CONN(*),FAM(*),NUM(*)
        CHARACTER*(*) NOM,MAA
        LOGICAL INUM,INOM
      END SUBROUTINE EFELEL

! ECRITURE DES NUMEROS DES FAMILLES DES ENTITES
! (NOEUDS/MAILLES/FACES/ARETES) D'UN MAILLAGE. 
      SUBROUTINE EFFAME(FID,MAA,FAM,N,TYPENT,TYPGEO,CRET)
        IMPLICIT NONE
        INTEGER FID,FAM(*),N,TYPENT,TYPGEO,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFFAME
    
! LECTURE DES NUMEROS DES FAMILLES DES ENTITES (NOEUDS/MAILLES/FACES/ARETES) 
! D'UN MAILLAGE
      SUBROUTINE EFFAML(FID,MAA,FAM,N,TYPENT,TYPGEO,CRET)
        IMPLICIT NONE
        INTEGER FID,FAM(*),N,TYPENT,TYPGEO,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFFAML
    
! ECRITURE DES INDICES DE COORDONNEES SELON UN AXE D'UNE GRILLE MED_GRILLE_CARTESIENNE OU MED_GRILLE_POLAIRE
      SUBROUTINE EFICOE(FID,MAA,MDIM,INDICES,N,AXE,COMP,UNIT,CRET)
        IMPLICIT NONE
        CHARACTER*(*) MAA
        DOUBLE PRECISION INDICES(*)
        INTEGER FID,MDIM,AXE
        INTEGER N,CRET
        CHARACTER*(*) COMP, UNIT
      END SUBROUTINE EFICOE

! LECTURE DES INDICES DE COORDONNEES SELON UN AXE D'UNE GRILLE
! MED_GRILLE_CARTESIENNE OU MED_GRILLE_POLAIRE.
      SUBROUTINE EFICOL(FID,MAA,MDIM,INDICES,N,AXE,COMP,UNIT,CRET)
        IMPLICIT NONE
        CHARACTER*(*) MAA
        DOUBLE PRECISION INDICES(*)
        INTEGER FID,MDIM,AXE
        INTEGER N,CRET
        CHARACTER*(*) COMP, UNIT
      END SUBROUTINE EFICOL
      
! RETOURNE SELON LA VALEUR DES PARAMETRES : 
! LE NOMBRE DE NOEUDS/MAILLES/FACES/ARETES D'UN MAILLAGE NON STRUCTURE
! LE NOMBRE DE NOEUDS D'UNE GRILLE MED_GRILLE STANDARD
! LE NOMBRE D'INDICES D'UNE GRILLE MED_GRILLE_CARTESIENNE OU
! MED_GRILLE_POLAIRE SELON UN AXE DONNE
      SUBROUTINE EFNEMA(FID, MAA, QUOI, TYPENT, TYPGEO,TYPCON,N,CRET)
        IMPLICIT NONE
        CHARACTER*(*) MAA
        INTEGER FID,TYPENT, TYPGEO,CRET,TYPCON,N,QUOI
      END SUBROUTINE EFNEMA

! ECRITURE GLOBALE DES ATTRIBUTS DES NOEUDS D'UN MAILLAGE NON STRUCTURE
      SUBROUTINE EFNOEE(FID,MAA,MDIM,COO,MODSWT,REP,NOMCOO,UNICOO,NOM,
     *                  INOM,NUM,INUM,FAM,N,CRET)
        IMPLICIT NONE
        INTEGER FID,MDIM,REP,N,CRET,MODSWT
        INTEGER NUM(*),FAM(*)
        LOGICAL INOM,INUM
        DOUBLE PRECISION COO(*)
        CHARACTER*(*) MAA,NOMCOO,UNICOO,NOM
      END SUBROUTINE EFNOEE

! LECTURE GLOBALE DES ATTRIBUTS DES NOEUDS D'UN MAILLAGE
      SUBROUTINE EFNOEL(FID,MAA,MDIM,COO,MODSWT,REP,NOMCOO,UNICOO,NOM,
     *                  INOM,NUM,INUM,FAM,N,CRET)
        IMPLICIT NONE
        INTEGER FID,MDIM,REP,CRET,MODSWT,N
        INTEGER NUM(*),FAM(*)
        LOGICAL INOM,INUM
        DOUBLE PRECISION COO(*)
        CHARACTER*(*) MAA,NOMCOO,UNICOO,NOM
      END SUBROUTINE EFNOEL

! ECRITURE DES NOMS DES ENTITES (NOEUDS/MAILLES/FACES/ARETES)
! D'UN MAILLAGE
      SUBROUTINE EFNOME(FID, MAA, NOM, N,TYPENT, TYPGEO,CRET)
        IMPLICIT NONE
        CHARACTER*(*) MAA
        CHARACTER*(*) NOM
        INTEGER FID,TYPENT, TYPGEO,CRET
        INTEGER N
      END SUBROUTINE EFNOME

! LECTURE DES NOMS DES ELEMENTS (NOEUDS/MAILLES/FACES/ARETES)
! D'UN MAILLAGE
      SUBROUTINE EFNOML(FID, MAA, NOM, N, TYPENT, TYPGEO,CRET)
        IMPLICIT NONE
        CHARACTER *(*) MAA
        CHARACTER*(*) NOM
        INTEGER FID,TYPENT, TYPGEO,CRET,N
      END SUBROUTINE EFNOML

! ECRITURE DES NUMEROS DES ENTITES (NOEUDS/MAILLES/FACES/ARETES)
! D'UN MAILLAGE
      SUBROUTINE EFNUME(FID, MAA, NUM, N, TYPENT, TYPGEO,CRET)
        IMPLICIT NONE
        CHARACTER*(*) MAA
        INTEGER NUM(*)
        INTEGER FID,TYPENT, TYPGEO,CRET
        INTEGER N
      END SUBROUTINE EFNUME

! LECTURE DES NUMEROS DES ENTITES (NOEUDS/MAILLES/FACES/ARETES)
! D'UN MAILLAGE
      SUBROUTINE EFNUML(FID, MAA, NUM, N,TYPENT, TYPGEO,CRET)
        IMPLICIT NONE
        CHARACTER *(*) MAA
        INTEGER NUM(*)
        INTEGER FID,TYPENT, TYPGEO,CRET,N
      END SUBROUTINE EFNUML

! ECRITURE DES CONNECTIVITES DES MAILLES DE TYPE MED_POLYEDRE 
      SUBROUTINE EFPECE(FID,MAA,INDEXP,NP,INDEXF,NF,CONN,TYPCON,CRET)
        IMPLICIT NONE
        CHARACTER*32 MAA
        INTEGER FID, CONN(*),TYPCON,CRET,INDEXP(*),INDEXF(*)
        INTEGER NP,NF
      END SUBROUTINE EFPECE

! ECRITURE DES CONNECTIVITES DES MAILLES DE TYPE MED_POLYEDRE 
      SUBROUTINE EFPECL(FID,MAA,INDEXP,NP,INDEXF,NF,CONN,TYPCON,CRET)
        IMPLICIT NONE
        CHARACTER*32 MAA
        INTEGER FID, CONN(*),TYPCON,CRET,INDEXP(*),INDEXF(*)
        INTEGER NP,NF
      END SUBROUTINE EFPECL
    
! ECRITURE DES CONNECTIVITES DES MAILLES/FACES DE TYPE MED_POLYGONE 
      SUBROUTINE EFPGCE(FID,MAA,INDEX,NI,CONN,TYPENT,TYPCON,CRET)
        IMPLICIT NONE
        CHARACTER *32 MAA
        INTEGER FID, CONN(*),TYPENT,TYPCON,CRET,INDEX(*)
        INTEGER NI
      END SUBROUTINE EFPGCE

! LECTURE DES CONNECTIVITES DES MAILLES/FACES DE TYPE MED_POLYGONE 
      SUBROUTINE EFPGCL(FID,MAA,INDEX,NI,CONN,TYPENT,TYPCON,CRET)
        IMPLICIT NONE
        CHARACTER*32 MAA
        INTEGER FID, CONN(*),TYPENT,TYPCON,CRET,INDEX(*)
        INTEGER NI
      END SUBROUTINE EFPGCL

! LECTURE DES INFORMATIONS CONCERNANT LES MAILLES DE TYPE MED_POLYEDRE 
      SUBROUTINE EFPYEI(FID,MAA,TYPCON,NF,CONSIZ,CRET)
        IMPLICIT NONE
        CHARACTER*32 MAA
        INTEGER FID,TYPCON,CRET
        INTEGER CONSIZ,NF
      END SUBROUTINE EFPYEI

! LECTURE DES INFORMATIONS PROPRES AUX MAILLES/FACES DE TYPE MED_POLYGONE
      SUBROUTINE EFPYGI(FID,MAA,TYPENT,TYPCON,CONSIZ,CRET)
        IMPLICIT NONE
        CHARACTER*32  MAA
        INTEGER FID,TYPENT,TYPCON,CRET
        INTEGER CONSIZ
      END SUBROUTINE EFPYGI

! ECRITURE DE LA STRUCTURE DES COORDONNEES D'UNE GRILLE DE TYPE
! MED_GRILLE_STANDARD
      SUBROUTINE EFSCOE(FID,MAA,MDIM,STRUCT,CRET)
        IMPLICIT NONE
        CHARACTER*(*)  MAA
        INTEGER STRUCT(*)
        INTEGER FID,CRET,MDIM
      END SUBROUTINE EFSCOE

! LECTURE DE LA STRUCTURE DES COORDONNEES D'UNE GRILLE DE TYPE
! MED_GRILLE_STANDARD
      SUBROUTINE EFSCOL(FID,MAA,MDIM,STRUCT,CRET)
        IMPLICIT NONE
        CHARACTER*(*)  MAA
        INTEGER STRUCT(*)
        INTEGER FID,CRET,MDIM
      END SUBROUTINE EFSCOL


!   INTERFACE MED FAMILLE


! CREATION D'UN FAMILLE DANS UN MAILLAGE
      SUBROUTINE EFFAMC(FID,MAA,FAM,NUM,ATTID,ATTVAL,ATTDES,NATT,
     *GRO,NGRO,CRET)
        INTEGER FID,NUM,ATTID,ATTVAL,NATT,NGRO,CRET
        CHARACTER *(*) MAA,FAM,ATTDES
        CHARACTER *(*) GRO
      END SUBROUTINE EFFAMC

! LECTURE DES INFORMATIONS SUR UNE FAMILLE. LES DONNEES LUES SONT :
! LE NOM. LE NUMERO. LES ATTRIBUTS. LES GROUPES. 
      SUBROUTINE EFFAMI(FID,MAA,IND,FAM,NUM,ATTID,ATTVAL,ATTDES,
     *NATT,GRO,NGRO,CRET)
        INTEGER FID,NUM,ATTID(*),ATTVAL(*),NATT,NGRO,CRET,IND
        CHARACTER *(*) MAA,FAM
        CHARACTER*80 ATTDES(*),GRO(*)
      END SUBROUTINE EFFAMI

! CETTE ROUTINE PERMET DE : 
! - CONVERTIR UNE LISTE DE GROUPES D'ENTITES EN FAMILLES D'ENTITES. 
! - CREER CES FAMILLES DANS LE MAILLAGE. 
! - ECRIRE LES NUMEROS DES FAMILLES DES ENTITES DANS LE MAILLAGE. 
      SUBROUTINE EFG2FC(FID,MAA,NOMGRO,IND,NGRO,ENTITE,NENT,TYPENT,
     *TYPGEO,INDGEO,NGEO,CRET)
        INTEGER          FID,CRET,NGRO,NENT,TYPENT,NGEO
        CHARACTER*32     MAA
        CHARACTER *80    NOMGRO(*)
        INTEGER          IND(*),INDGEO(*),ENTITE(*),TYPGEO(*)
      END SUBROUTINE EFG2FC

! LECTURE DU NOMBRE D'ATTRIBUT DANS UNE FAMILLE.
      SUBROUTINE EFNATT(FID,MAA,IND,N,CRET)
        INTEGER FID,IND,N,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFNATT

! LECTURE DU NOMBRE DE FAMILLE DANS UN MAILLAGE.
      SUBROUTINE EFNFAM(FID,MAA,N,CRET)
        IMPLICIT NONE
        INTEGER FID,N,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFNFAM

! LECTURE DU NOMBRE DE GROUPE DANS UNE FAMILLE
      SUBROUTINE EFNGRO(FID,MAA,IND,N,CRET)
        INTEGER FID,IND,N,CRET
        CHARACTER *(*) MAA
      END SUBROUTINE EFNGRO


!   INTERFACE MED EQUIVALENCE

! CREATION D'UNE EQUIVALENCE DANS UN MAILLAGE
      SUBROUTINE EFEQUC ( FID , MAA , EQ , DESC , CRET)
        CHARACTER *(*) MAA, DESC, EQ
        INTEGER FID, CRET
      END SUBROUTINE EFEQUC

! ECRITURE DES CORRESPONDANCES 2 A 2 ASSOCIEES A UNE EQUIVALENCE
! POUR UN TYPE GEOMETRIQUE D'UNE ENTITE DU MAILLAGE.
      SUBROUTINE EFEQUE (FID,MAA,EQ,CORR,N,TYPENT,TYPGEO,CRET)
        INTEGER FID, CRET, CORR(*), N, TYPENT, TYPGEO
      END SUBROUTINE EFEQUE

! LECTURE DES INFORMATIONS SUR UNE EQUIVALENCE. LES DONNEES LUES SONT :
! LE NOM. LA DESCRIPTION. 
      SUBROUTINE EFEQUI(FID,MAA,IND,EQ,DES,CRET)
        CHARACTER *(*) MAA,EQ,DES
        INTEGER FID, CRET,IND
      END SUBROUTINE EFEQUI

! LECTURE DES CORRESPONDANCES 2 A 2 ASSOCIEES A UNE EQUIVALENCE
! POUR UN TYPE GEOMETRIQUE D'UNE ENTITE DU MAILLAGE
      SUBROUTINE EFEQUL(FID,MAA,EQ,CORR,N,TYPENT,TYPGEO,CRET)
        CHARACTER *(*) MAA, EQ
        INTEGER FID, CRET, CORR(*), N,TYPENT, TYPGEO
      END SUBROUTINE EFEQUL

! LECTURE DU NOMBRE DE CORRESPONDANCE DANS UNE EQUIVALENCE
! POUR UN TYPE D'ENTITE DONNE
      SUBROUTINE EFNCOR(FID,MAA,EQ,TYPENT,TYPGEO,N,CRET)
        CHARACTER *(*) MAA, EQ
        INTEGER FID, CRET, N,TYPENT, TYPGEO
      END SUBROUTINE EFNCOR

! LECTURE DU NOMBRE D'EQUIVALENCE DANS UN MAILLAGE
      SUBROUTINE EFNEQU(FID,MAA,N,CRET)
        CHARACTER*(*) MAA
        INTEGER FID, CRET, N
      END SUBROUTINE EFNEQU

!   INTERFACE MED CHAMP

! CREATION D'UN CHAMP DANS UN FICHIER. 
      SUBROUTINE EFCHAC(FID,CHA,TYPE,COMP,UNIT,NCOMP,CRET)
        CHARACTER*32 CHA
        CHARACTER*16 COMP(*),UNIT(*)
        INTEGER FID, NCOMP, CRET, TYPE
      END SUBROUTINE EFCHAC

! RETOURNE LES INFORMATIONS PROPRES A L'IDENTIFICATION D'UN CHAMP : 
! NOM DU CHAMP. NOMS ET UNITES DES COMPOSANTES. TYPE DES COMPOSANTES
      SUBROUTINE EFCHAI(FID,IND,CHA,TYPE,COMP,UNIT,NCOMP,CRET)      
        CHARACTER*(*) CHA,COMP,UNIT      
        INTEGER FID,IND,TYPE,NCOMP,CRET
      END SUBROUTINE EFCHAI

! LECTURE DES VALEURS DANS UN CHAMP DE RESULTAT 
      SUBROUTINE EFCHAL(FID,MAA,CHA,VAL,MODSWT,NUMCO,LOCNAME,PROFIL,
     *                  PFLMOD,TYPENT,TYPGEO,NUMDT,NUMO,CRET)
        CHARACTER*(*) CHA,MAA,LOCNAME,PROFIL      
        INTEGER FID,TYPENT,TYPGEO,CRET 
        DOUBLE PRECISION, INTENT(OUT) :: VAL(*)     
        INTEGER MODSWT,NUMCO,PFLMOD,NUMDT,NUMO
      END SUBROUTINE EFCHAL

! ECRITURE DE VALEURS DANS UN CHAMP DE RESULTAT 
      SUBROUTINE EFCHAE(FID,MAA,CHA,VAL,MODSWT,N,LOCNAME,NUMCO,PROFIL,
     *PFLMOD,TYPENT,TYPGEO,NUMDT,DTUNIT,DT,NUMO,CRET)
        CHARACTER*(*) CHA,MAA,PROFIL,LOCNAME      
        CHARACTER*16 DTUNIT      
        INTEGER FID     
        INTEGER N,PFLMOD,TYPENT,TYPGEO,CRET      
        INTEGER MODSWT,NUMCO,NUMDT,NUMO      
        DOUBLE PRECISION DT,VAL(*)
      END SUBROUTINE EFCHAE

! CETTE ROUTINE PERMET DE REFERENCER LE FICHIER <LIENVAL>
! COMME ETANT CELUI QUI PORTE LE MAILLAGE <MAA>. 
      SUBROUTINE EFLIEE(FID,LIENVAL,MAA,CRET)
        INTEGER FID,CRET      
        CHARACTER*(*) LIENVAL, MAA
      END SUBROUTINE EFLIEE
    
! CETTE ROUTINE LIT LES INFORMATIONS SUR UN LIEN SUR FICHIER DISTANT
      SUBROUTINE EFLIEI(FID,INDICE,MAA,N,CRET)
        CHARACTER*(*) MAA
        INTEGER FID,INDICE,N,CRET
      END SUBROUTINE EFLIEI

! PERMET DE LIRE LE LIEN <LIENVAL> ASSOCIE AU MAILLAGE DISTANT <MAA>. 
      SUBROUTINE EFLIEL(FID,LIENVAL,N,MAA,CRET)
        CHARACTER*(*) MAA,LIENVAL
        INTEGER FID,N,CRET
      END SUBROUTINE EFLIEL

! RETOURNE LE NOMBRE DE CHAMP DANS LE FICHIER SI "IND" EST EGAL A 0 OU
! LE NOMBRE DE COMPOSANTES DU CHAMP CORRESPONDANT A L'INDICE "IND". 
      SUBROUTINE EFNCHA(FID,IND,N,CRET)
        INTEGER FID,IND,CRET,N
      END SUBROUTINE EFNCHA

! CETTE ROUTINE RENVOIE LE NOMBRE DE LIEN SUR FICHIER
! DISTANT DANS UN FICHIER
      SUBROUTINE EFNLIE(FID,N,CRET)
        INTEGER FID,N,CRET
      END SUBROUTINE EFNLIE

! CETTE ROUTINE PERMET DE DECOUVRIR POUR LE CHAMP <CHA> L'EXISTENCE
! DE VALEURS SUR LES ENTITES <TYPENT> DE TYPE GEOMETRIQUE <TYPEGEO>
      SUBROUTINE EFNPDT(FID,CHA,TYPENT,TYPGEO,N,CRET)
        INTEGER FID,TYPENT,TYPGEO,N,CRET
        CHARACTER*32 CHA
      END SUBROUTINE EFNPDT

! RETOURNE LE NOMBRE DE VALEURS DU CHAMP <CHA> A L'ETAPE DE CALCUL
! (<NUMDT>,<NUMO>) SUR LES ENTITES <TYENT> DE TYPE GEOMETRIQUE
! <TYPGEO> DU MAILLAGE <MAA>. 
      SUBROUTINE EFNVAL(FID,CHA,TYPENT,TYPGEO,NUMDT,NUMO,MAA,PFLMOD,N,
     *                  CRET)
        INTEGER FID,TYPENT,TYPGEO,N,CRET
        INTEGER NUMDT, NUMO, PFLMOD 
        CHARACTER *(*) CHA, MAA
      END SUBROUTINE EFNVAL

! CETTE ROUTINE PERMET DE CONNAITRE LA TAILLE DU LIEN ASSOCIEE AU
! MAILLAGE DISTANT <MAA>.
      SUBROUTINE EFNVLI(FID,MAA,N,CRET)
        CHARACTER*(*) MAA
        INTEGER FID,N,CRET
      END SUBROUTINE EFNVLI

! CETTE ROUTINE RENVOIE LE NOMBRE DE MAILLAGES ASSOCIES AU CHAMP <CHA>
! SUR LES ENTITES <TYPENT> DE TYPE GEOMETRIQUE <TYPGEO> A L'ETAPE DE
! CALCUL (<NUMDT>,<NUMO>). 
      SUBROUTINE EFNREF(FID,CHA,TYPENT,TYPGEO,NUMDT,NUMO,N,CRET)
        INTEGER FID,TYPENT,TYPGEO,NUMDT,NUMO,N,CRET
        CHARACTER*32 CHA
      END SUBROUTINE EFNREF

! LECTURE DES INFORMATIONS CARACTERISANT UNE SEQUENCE DE CALCUL
! (PAS DE TEMPS, NUMERO D'ORDRE)
      SUBROUTINE EFPDTI(FID,CHA,TYPENT,TYPGEO,IND,NGAUSS,NUMDT,NUMO,
     *     DTUNIT,DT,MAA,LOCAL,NMAA,CRET)
        INTEGER FID,TYPENT,TYPGEO,IND,NGAUSS,NUMDT,NUMO,NMAA,CRET
        CHARACTER*32 CHA,MAA
        CHARACTER*16 DTUNIT
        LOGICAL LOCAL
        DOUBLE PRECISION DT
      END SUBROUTINE EFPDTI

! LA ROUTINE MEDCHAMPREFINFO/EFREFI PERMET D'IDENTIFIER UN MAILLAGE
! REFERENCE DANS UNE SEQUENCE DE CALCUL. LES DONNEES LUES SONT : 
! LE NOM DU MAILLAGE, SA LOCALISATION, LE NOMBRE DE POINTS DE GAUSS 
      SUBROUTINE EFREFI(FID,CHA,TYPENT,TYPGEO,INDICE,NUMDT,NUMO,
     *                  MAA,LOCAL,NGAUSS,CRET)
        INTEGER FID,TYPENT,TYPGEO,INDICE,CRET
        INTEGER NUMDT, NUMO, NGAUSS
        CHARACTER*(*) CHA, MAA
        LOGICAL LOCAL
      END SUBROUTINE EFREFI

!   INTERFACE MED PROFIL

! RENVOIE LE NOMBRE DE PROFILS DANS UNE FICHIER DONT LE DESCRIPTEUR ID
! EST PASSE EN PARAMETRE
      SUBROUTINE EFNPRO(FID,N,CRET)
        INTEGER FID, N, CRET
      END SUBROUTINE EFNPRO

! LECTURE DES VALEURS D'UN PROFIL
      SUBROUTINE EFPFLL(FID,PFLVAL,NOM,CRET)
        INTEGER FID,CRET
        INTEGER PFLVAL(*)
        CHARACTER*(*) NOM
      END SUBROUTINE EFPFLL

! CREATION D'UN PROFIL DE CHAMP
      SUBROUTINE EFPFLE(FID,PFLVAL,N,NOM,CRET)
        INTEGER FID,N,CRET
        INTEGER PFLVAL(*)
        CHARACTER*(*) NOM
      END SUBROUTINE EFPFLE

! RETOURNE LA TAILLE DU PROFIL (NOMBRE DE VALEURS) DU PROFIL "NOM". 
      SUBROUTINE EFNPFL(FID,NOM,N,CRET)
        INTEGER FID,CRET,N
        CHARACTER*(*) NOM
      END SUBROUTINE EFNPFL

! RENVOIE LES INFORMATIONS RELATIVES A UN PROFIL DONNE
! (NOM, TAILLE) DANS UN FICHIER DONT LE DESCRIPTEUR (ID) EST PASSE EN PARAMETRE
      SUBROUTINE EFPROI(FID , INDICE , PRO , N , CRET)
        INTEGER FID, INDICE, N, CRET
        CHARACTER*(*) PRO
      END SUBROUTINE EFPROI

!      INTERFACE MED JOINT

! Creation d'un joint dans un maillage
      subroutine efjntc(fid,maalcl,jn,desc,dom,maadst,cret)
        character*(*) maalcl, maadst, desc, jn
        integer fid, dom, cret
      end subroutine efjntc

! Lecture du nombre de joints dans un maillage
      subroutine efnjnt(fid,maa,n,cret)
      character*(*) maa
      integer fid, cret, n
      end subroutine efnjnt

! Lecture des informations sur un joint. Les donnees sont :
!    *  Le nom.
!    * La description.
!    * Les noms des maillages local et distant auquel il se rapporte.
!    * Le num
      Subroutine efjnti(fid, maalcl, ind, jn, desc, dom, maadst,cret)
      character*(*) maalcl,maadst,jn,desc
      integer fid, cret,ind,dom
      end subroutine efjnti

! Ecriture du contenu d'une correspondance dans un joint 
! pour les couples de type passes en parametre

      subroutine efjnte ( fid , maalcl , jn , corrtab, n, 
     *     entlcl, geolcl, entdst, geodst,
     *     cret)
      character*(*) maalcl, jn
      integer n, fid, dom, cret, corrtab(*)
      integer entlcl, entdst, geolcl, geodst
      integer edfjcol
      end subroutine efjnte

! Lecture du contenu d'une correspondance dans un joint 
! pour les couples de type passes en parametres

      Subroutine efjntl ( fid , maalcl , jn , corrtab, n ,
     *     entlcl, geolcl, entdst, geodst, cret)
      character*(*) maalcl, jn
      integer n, fid, dom, cret, corrtab(*)
      integer entlcl, entdst, geolcl, geodst
      integer edfjcol
      end subroutine efjntl

! Lecture du nombre de correspondance dans un joint 
! pour deux types donnes en regard

      subroutine efjnco(fid,maalcl,jn,entlcl,geolcl,
     *     entdst,geodst,nc,cret)
      character*(*) maalcl, jn
      integer fid, entlcl,geolcl,entdst,geodst,cret, n
      end subroutine efjnco
      
! Lecture du type des donnees en regard dans une correspondance

      subroutine efjtco(fid,maalcl,jn,entlcl, geolcl, 
     *     entdst, geodst, cret)
      character*(*) maalcl, jn
      integer fid, entlcl,geolcl,entdst,geodst,cret, n
      end subroutine efjtco

! Ecriture d'une numerotation globale sur un maillage 
! pour un type d'entite et un type geometrique donne

      Subroutine efgnme ( fid , maa , numtab, n,
     *     ent, geo, cret)
      character*(*) maa
      integer n, fid,  cret, numtab(*)
      integer ent, geo
      end subroutine efgnme

! Lecture d'une numerotation globale sur un maillage 
! pour un type d'entite et un type geometrique donne

      subroutine efgnml ( fid , maa , numtab, n,
     *     ent, geo, cret)
      character*(*) maa
      integer n, fid,  cret, numtab(*)
      integer ent, geo
      end subroutine efgnml
      
      End INTERFACE
!
!
!
!
!
!
!
      CONTAINS
!-----------------------------------------------------------------------
      SUBROUTINE MED_CHECK_CRET(CRET,TEXTE)
!-----------------------------------------------------------------------
! AUTHORS: J HOLLEVILLE
!-----------------------------------------------------------------------
! FUNCTION: CHECK THE RETURN VARIABLE OF A MED CALL
!           STOP EXECUTION IF AN ERROR OCCURED.
!-----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
!-----------------------------------------------------------------------
    
! GLOBAL DECLARATIONS
!-----------------------------------------------------------------------
! LOCAL DECLARATIONS
        INTEGER,          INTENT(IN) :: CRET
        CHARACTER(LEN=6), INTENT(IN) :: TEXTE
!-----------------------------------------------------------------------
!       IF (DEBUG) CALL PROC_BEGIN('CHECK_MED_CALL')
!-----------------------------------------------------------------------

        IF(CRET.EQ.-1) THEN
          IF(LNG.EQ.1) WRITE(LU,*) 'ERREUR MED : ',TEXTE
          IF(LNG.EQ.2 )WRITE(LU,*) 'ERROR MED : ',TEXTE
          CALL PLANTE(1)
          STOP
        ENDIF

!-----------------------------------------------------------------------
!       IF (DEBUG) CALL PROC_END('CHECK_MED_CALL')
!-----------------------------------------------------------------------

      RETURN
      END SUBROUTINE MED_CHECK_CRET
!
!***********************************************************************
      SUBROUTINE OPEN_FILE_MED(MEDNAME,MEDFILE,ACTION)
!***********************************************************************
! FUNCTION : 
! OPEN A MED DATA FILE. IT WAS ALREADY CHECKED, THAT THE FILE IS NOT
! ALREADY IN USE. THUS, THIS CHECK IS NOT DONE AGAIN.
! THE FILE IS OPENED IN THE SPECIFIED MODE (RO, RW OR WO)
! THE ID OF THE MED FILE IS RETURNED AS PART OF THE FILE DESCRIPTOR
! MEDFILE%CANAL.
!***********************************************************************
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
! ARGUMENTS :
      INTEGER, INTENT(INOUT) :: MEDFILE
      CHARACTER(LEN=*), INTENT(IN) :: MEDNAME
      CHARACTER(LEN=9) :: ACTION

!***********************************************************************
! LOCAL DECLARATIONS :
      INTEGER :: CRET ! RETURN CODE OF THE CALLED MED LIBRARY FUNCTION
      LOGICAL :: ISOK ! STATUS CHECK ON THE SUBROUTINE.
      INTEGER :: MED_MODE
!***********************************************************************
!     IF ( DEBUG ) CALL PROC_BEGIN('OPEN_FILE_MED')
!***********************************************************************

      CRET = 0
      ISOK = .TRUE.

!     CHECK THE MODE. POSSIBLE MODES ARE READONLY, WRITEONLY OR
!     READWRITE. OTHER MODES ARE INVALID.

      SELECT CASE(ACTION)
         CASE('READ     ')
             MED_MODE = MED_LECTURE
         CASE('READWRITE')
            MED_MODE = MED_LECTURE_ECRITURE
!             MED_MODE = MED_CREATION
         CASE('WRITE    ')
             MED_MODE = MED_CREATION
         CASE DEFAULT
          IF(LNG.EQ.1) THEN
            WRITE(LU,*)'ACTION ERRONEE DANS OPEN_FILE_MED :',ACTION
          ENDIF
          IF(LNG.EQ.2) THEN
            WRITE(LU,*)'BAD ACTION IN OPEN_FILE_MED:',ACTION
          ENDIF
          CALL PLANTE(1)
          STOP
      END SELECT

! OPEN THE MED FILE AND CHECK RETURN CODE.
      IF ( ISOK ) THEN 
        CALL EFOUVR(MEDFILE,MEDNAME,MED_MODE,CRET)
        ! MMED_CHECK WILL EXIT ON AN ERROR ....
        CALL MED_CHECK_CRET(CRET,'EFOUVR')
      END IF

!***********************************************************************
!     IF ( DEBUG ) CALL PROC_END('OPEN_FILE_MED')
!***********************************************************************
      END SUBROUTINE OPEN_FILE_MED
!
!***********************************************************************
      SUBROUTINE CLOSE_FILE_MED(MEDFILE)
!***********************************************************************
! BIEF V6PX                                               RN   JUNE 2008
!***********************************************************************
! FUNCTION :
! CLOSE A MED DATA FILE
!
!***********************************************************************
      IMPLICIT NONE
!***********************************************************************
! ARGUMENTS :
      INTEGER, INTENT(IN)  :: MEDFILE

!***********************************************************************
! LOCAL DECLARATIONS :
      INTEGER :: CRET

!***********************************************************************
!     IF(DEBUG) CALL PROC_BEGIN('CLOSE_FILE_MED')
!***********************************************************************

      CALL EFFERM(MEDFILE,CRET)
      CALL MED_CHECK_CRET(CRET,'EFFERM')

!***********************************************************************
!     IF(DEBUG) CALL PROC_END('CLOSE_FILE_MED')
!***********************************************************************
      RETURN
      END SUBROUTINE CLOSE_FILE_MED
!***********************************************************************
!
!***********************************************************************
      SUBROUTINE WRITE_MESH_MED(RES_FILE,MESH,X_ORIG,Y_ORIG)
!***********************************************************************
! BIEF V6P0                                               RN   JUNE 2008
!***********************************************************************
! FUNCTION :
! DESCRIBE YOUR SUBROUTINE HERE : FUNCTION AND EVENTUALLY ALGORITHM.
!
!***********************************************************************
!
      USE BIEF
!
      IMPLICIT NONE
!***********************************************************************
! ARGUMENTS :
      INTEGER        , INTENT(IN)  :: RES_FILE
      TYPE(BIEF_MESH), INTENT(IN)  :: MESH
      DOUBLE PRECISION,INTENT(IN)  :: X_ORIG
      DOUBLE PRECISION,INTENT(IN)  :: Y_ORIG

!***********************************************************************
! LOCAL DECLARATIONS :

      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: COOR
      CHARACTER(LEN=32) :: TITRE ! NOM DU MAILLAGE
      CHARACTER(LEN=16), DIMENSION(:), ALLOCATABLE :: NOMCOORD, UNICOORD
      INTEGER :: CRET
      INTEGER :: I
      INTEGER :: TYP_MED
! NUMERO ET NOM DE LA FAMILLE
      INTEGER           :: NUMFAM
      CHARACTER(LEN=32) :: NOMFAM

!***********************************************************************
!     IF(DEBUG) CALL PROC_BEGIN('WRITE_MESH_MED')
!***********************************************************************

      ! WRITE THE FILE DESCRIPTOR : 
      TITRE = 'BIEF_MESH'
      CALL EFFIDE(RES_FILE,TITRE,CRET)
      CALL MED_CHECK_CRET(CRET,'EFFIDE')

      ! WRITE THE MESH DESCRIPTOR :
      ! FURTHERON, THE MESH WILL ALWAYS BE ADDRESSED BY THE FILE ID AND
      ! THE MESH NAME (A MED FILE MAY CONTAIN MORE THAN ONE MESH, THEIR
      ! NAMES SHOULD BE DIFFERENT)
      TITRE = MESH%NAME
      CALL EFMAAC(RES_FILE,TITRE,MESH%DIM,MED_NON_STRUCTURE,
     *            'PAS_DE_DESCRIPTION',CRET)
      CALL MED_CHECK_CRET(CRET,'EFMAAC')
!      
      ALLOCATE(COOR(MESH%NPOIN*MESH%DIM))
      DO I = 1,MESH%NPOIN
        COOR(I) = MESH%X%R(I)+X_ORIG
        COOR(I+MESH%NPOIN) = MESH%Y%R(I)+Y_ORIG
      ENDDO
      IF (MESH%DIM .EQ. 3 ) THEN
      DO I = 1, MESH%NPOIN
        COOR(I+2*MESH%NPOIN) = MESH%Z%R(I)
      ENDDO
      ENDIF

      
      ALLOCATE(NOMCOORD(MESH%DIM),UNICOORD(MESH%DIM))
      NOMCOORD(1) = 'X'; UNICOORD(1) = 'M'
      NOMCOORD(2) = 'Y'; UNICOORD(2) = 'M'
      IF(MESH%DIM .EQ. 3 ) THEN
        NOMCOORD(3) = 'Z'; UNICOORD(3) = 'M'
      ENDIF

      call MED_CHECK_CRET(1,'FINFIN')
      CALL EFCOOE(RES_FILE,         ! FILE UNIT 
     *            TITRE,            ! TITLE OF THE MESH 
     *            MESH%DIM,         ! MESH DIMENSION
     *            COOR,             ! TABLE OF THE COORDINATES
     *            MED_NO_INTERLACE, ! STORAGE MODE FOR COORDINATES
     *            MESH%NPOIN,       ! NUMBER OF NODES
     *            MED_CART,         ! CARTESIAN OR SPHERICAL? 
     *            NOMCOORD,         ! NAME OF COORDINATES
     *            UNICOORD,         ! UNITS FOR COORDINATES
     *            CRET)             ! RETURN CODE
      CALL MED_CHECK_CRET(CRET,'EFCOOE')

      ! THE TYPE OF THE ELEMENTS : GET THE MED ELEMENT TYPE
      IF(MESH%TYPELM.EQ.10) THEN
        TYP_MED = MED_TRIA3 
      ELSEIF(MESH%TYPELM.EQ.20) THEN
        TYP_MED = MED_QUAD4 
      ELSEIF(MESH%TYPELM.EQ.30) THEN
        TYP_MED = MED_TETRA4
      ELSEIF(MESH%TYPELM.EQ.40) THEN
        TYP_MED = MED_PENTA6 
      ELSE
        WRITE(6,*) 'ERROR!'
        CALL PLANTE(1)
        STOP
      ENDIF
   
      
      ! WRITE THE CONNECTIVITY INTO THE MED DATA FILE :
      CALL EFCONE(RES_FILE,        ! FILE UNIT
     *            TITRE,           ! TITLE OF THE MESH
     *            MESH%DIM,        ! DIMENSION OF THE MESH
     *            MESH%IKLE%I,     ! CONNECTIVITY
     *            MED_NO_INTERLACE,! STORAGE MODE FOR CONNECTIVITY
     *            MESH%NELEM,      ! NUMBER OF ELEMENTS
     *            MED_MAILLE,      ! WRITE THE ELEMENTS
     *            TYP_MED,         ! TYPE OF ELEMENTS
     *            MED_NOD,         ! NODAL CONNECTIVITY
     *            CRET)            ! RETURN CODE
      CALL MED_CHECK_CRET(CRET,'EFCONE')


      !CREATION DE LA FAMILLE 0
      NUMFAM = 0
      NOMFAM="FAMILLE_ZERO"
      CALL EFFAMC(RES_FILE,TITRE,nomfam,numfam,0,0,' ',
     *          0,' ',0,cret)
      CALL MED_CHECK_CRET(CRET,'EFFAMC')

     
!***********************************************************************
!     IF(DEBUG) CALL PROC_END('WRITE_MESH_MED')
!***********************************************************************
      RETURN
      END SUBROUTINE WRITE_MESH_MED
C                       *****************************
                        SUBROUTINE CREATE_DATASET_MED
C                       *****************************
C
     *(FILERES,TITLE,NVAR,NOMVAR,OUTVAR)
C
C***********************************************************************
C BIEF VERSION 5.9           29/04/2008  J HOLLEVILLE (INCKA)   47 80 79
C                            05/09/2008  RN
C***********************************************************************
C
C FUNCTION :
C CREATE THE DATA FIELDS FOR THE MED DATA FILE. A DATA FIELD IS DEFINED
C BY A NAME, A UNIT, A TYPE (INTEGER OR REAL) AND THE NUMBER OF
C COMPONENTS (A 2D VECTOR HAS 2 COMPONENTS, A 3D VECTOR HAS 3 COMPONENTS
C ...)
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________
C |      NOM       |MODE|                   ROLE
C |________________|____|______________________________________________
C |   FILERES      | -->| LOGICAL UNIT OF FILE
C |   TITLE        | -->| TITRE DU MAILLAGE
C |   NAR          | -->| NUMBER OF VARIABLES TO BE PUT IN THE FILE
C |   NOMVAR       | -->| NAME OF VARIABLES 
C |   OUTVAR       | -->| VARIABLES TO BE PUT IN THE FILE 
C |________________|____|______________________________________________
C MODE : -->(DONNEE NON MODIFIEE), <--(RESULTAT), <-->(DONNEE MODIFIEE)
C-----------------------------------------------------------------------
C
C PROGRAMMES APPELES : RIEN EN STANDARD
C
C***********************************************************************
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER                          , INTENT(IN) :: FILERES
      CHARACTER(LEN=72)                , INTENT(IN) :: TITLE
      INTEGER                          , INTENT(IN) :: NVAR
      CHARACTER(LEN=32),DIMENSION(NVAR), INTENT(IN) :: NOMVAR
      LOGICAL          ,DIMENSION(NVAR), INTENT(IN) :: OUTVAR
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER :: DIMVEC ! DIMENSION OF VECTOR
      INTEGER           :: NCOMP
      INTEGER           :: CRET
      CHARACTER(LEN=32) :: NOMCHAMED
      CHARACTER(LEN=16) :: NOM,UNI,NOMX,NOMY,NOMZ
      CHARACTER(LEN=32) :: NOMVAR2
      INTEGER           :: TYP_MED
      INTEGER           :: IVAR
      CHARACTER(LEN=32) :: CHA
      INTEGER           :: ISFIRST
      LOGICAL           :: OK   
      CHARACTER(LEN=64) :: NAME  
      CHARACTER(LEN=64) :: VUNIT  
      CHARACTER(LEN=16),DIMENSION(:),allocatable :: NAME2  
      CHARACTER(LEN=16),DIMENSION(:),allocatable :: VUNIT2     
!LOCAL DECLARATION
      INTEGER           :: NB_VAR
            

!***********************************************************************
!     IF(DEBUG) CALL PROC_BEGIN('CREATE_DATASET_MED')
!***********************************************************************


      DIMVEC = 1
      DO IVAR=1,NVAR
        IF (.NOT.OUTVAR(IVAR)) CYCLE
        NOMVAR2   = NOMVAR(IVAR)
        CALL BLANC2_(NOMVAR2)
        call IFVECTOR_(NOMVAR2,ISFIRST,OK)
        DIMVEC = max(DIMVEC,ISFIRST)  
      ENDDO
        NOMX = 'X'
        NOMY = 'Y'
        NOMZ = 'Z'
        NB_VAR=0
      DO IVAR = 1, NVAR
        IF (.NOT.OUTVAR(IVAR)) CYCLE
        NB_VAR=NB_VAR+1
        NOMVAR2   = NOMVAR(IVAR)
        CALL BLANC2_(NOMVAR2)
        NOMCHAMED = NOMVAR2(1:16)//CHAR(0)
        NOM       = '_'
        UNI       = NOMVAR2(17:32)//CHAR(0)
        NCOMP     = 1 
        TYP_MED   = MED_FLOAT64        
        call IFVECTOR_(NOMCHAMED,ISFIRST,OK)
        if (ok) NCOMP = DIMVEC 
        if ((ok.and.isfirst==1).or.(.not.ok)) then
         if(ok) then
            NAME = NOMX//NOMY//NOMZ
            VUNIT = UNI//UNI//UNI
         else
            NAME = NOM
            VUNIT = UNI
         endif

        CALL EFCHAC(FILERES,         ! FILE TO WRITE TO
     *              NOMCHAMED,       ! NAME OF THE DATA FIELD
     *              TYP_MED,         ! TYPE (REAL, INTEGER)
     *              NAME,            ! ???
     *              VUNIT,           ! UNITS
     *              NCOMP,           ! NUMBER OF COMPONENTS
     *              CRET)            ! RETURN CODE
        CALL MED_CHECK_CRET(CRET,'EFCHAC') 
        endif
      ENDDO


!Preparation pour l'ecriture du champ de scalaires pour les maillages 
!deformees
      IF (DIMVEC==3) THEN
          allocate(NAME2((3+NB_VAR)),VUNIT2((3+NB_VAR)))
          NOMVAR2   = 'MODIF FIELD'
          CALL BLANC2_(NOMVAR2)
          NOMCHAMED = NOMVAR2(1:16)//CHAR(0)
          NAME2(1)    = 'X'
          VUNIT2(1)   = 'M'
          NAME2(2)    = 'Y'
          VUNIT2(2)   = 'M'
          NAME2(3)    = 'Z'
          VUNIT2(3)   = 'M'
          NB_VAR=0
          DO IVAR = 1, NVAR
              IF (.NOT.OUTVAR(IVAR)) CYCLE
              NB_VAR=NB_VAR+1
              NOMVAR2   = NOMVAR(IVAR)
              CALL BLANC2_(NOMVAR2)
              NAME2(3+NB_VAR) =NOMVAR2(1:16)
              VUNIT2(3+NB_VAR) = NOMVAR2(17:32)
          ENDDO
          NCOMP      = 3+NB_VAR

        CALL EFCHAC(FILERES,         ! FILE TO WRITE TO
     *              NOMCHAMED,       ! NAME OF THE DATA FIELD
     *              TYP_MED,         ! TYPE (REAL, INTEGER)
     *              NAME2,           ! ???
     *              VUNIT2,          ! UNITS
     *              NCOMP,           ! NUMBER OF COMPONENTS
     *              CRET)            ! RETURN CODE
        CALL MED_CHECK_CRET(CRET,'EFCHAC')
         deallocate(NAME2,VUNIT2)
      ENDIF
      
!***********************************************************************
!     IF(DEBUG) CALL PROC_END('CREATE_DATASET_MED')
!***********************************************************************

      RETURN
      END SUBROUTINE CREATE_DATASET_MED
C                       *************************
                        SUBROUTINE WRITE_DATA_MED
C                       *************************
C
     *(FILERES,NVARS,TIME,TIMESTEP,NOMVAR,OUTVAR,BVARSOR)
C
C***********************************************************************
C BIEF VERSION 5.9           25/11/08    J HOLLEVILLE (INCKA) 
C***********************************************************************
C
C FUNCTION : WRITE DATA VALUES ON A MESH INTO THE MED DATA FILE.
C            DATA VALUES ARE STORED IN A BIEF_OBJ BLOCK (BVARSOR),
C            AND THE LOGICAL OUTVAR INDICATES FOR EACH VARIABLE IF 
C            WE SHOULD PRINT IT OUT OR NOT. THE BLOCK BVARSOR CONTAINS
C            ALL VARIABLES WHICH WE CAN WRITE OUT. IF THE VARIABLE IS A
C            VECTOR, THE CORRESPONDING ENTRY INTO THE BLOCK BVARSOR IS
C            A BLOCK, HAVING AS MUCH COMPONENTS AS THE VECTOR HAS.
C            TODO / TOCHECK : IF IT IS A TENSOR ...
C TIME IS GIVEN AS A REAL NUMBER, TIMESTEPS ARE INTEGER VALUES.
C TODO / TOCHECK : ARE THIS THE TIMESTEPS OF SIMULATION OR OF OUTPUT?
C !!!! THE ALGORITHM FOR NAMING THE DATA FIELDS SHOULD BE THE SAME AS
C FOR THE SUBROUTINE CREATING THIS FIELDS (MED_DATASET_CREATE)
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________
C |      NOM       |MODE|                   ROLE
C |________________|____|______________________________________________
C |   FFORMAT      | -->| FILE FORMAT
C |   FILERES      | -->| LOGICAL UNIT OF FILE
C |   OUTVAR       | -->| VARIABLES TO BE PUT IN THE FILE
C |   NOMVAR       | -->| NAME OF VARIABLES 
C |   BVARSOR      | -->| BIEF BLOCK CONTAINING THE VARIABLES VARIABLES 
C |________________|____|______________________________________________
C MODE : -->(DONNEE NON MODIFIEE), <--(RESULTAT), <-->(DONNEE MODIFIEE)
C-----------------------------------------------------------------------
C
C PROGRAMMES APPELES : RIEN EN STANDARD
C
C***********************************************************************
C
      USE BIEF
      USE DECLARATIONS_TELEMAC, only : NNAMECODE
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER          ,INTENT(IN)                   :: FILERES
      INTEGER          ,INTENT(IN)                   :: NVARS
      DOUBLE PRECISION ,INTENT(IN)                   :: TIME
      INTEGER          ,INTENT(IN)                   :: TIMESTEP
      CHARACTER(LEN=32),DIMENSION(NVARS), INTENT(IN) :: NOMVAR
      LOGICAL          ,DIMENSION(NVARS), INTENT(IN) :: OUTVAR
      TYPE(BIEF_OBJ)   ,INTENT(IN)                   :: BVARSOR
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER :: CRET    ! RETURN CODE
      INTEGER :: IVAR    ! VARIABLE ID TO OUTPUT
      INTEGER :: NDATA   ! NUMBER OF DATA POINTS TO WRITE
      INTEGER :: TYP_MED ! NUMBER OF COMPONENTS
!BD_INCKA  modif dans le cas d'une decompostion P0
      INTEGER :: TYP_DISC
!BD_INCKA fin modif
C
      INTEGER :: NUMMESH
      INTEGER, DIMENSION(1) ::  VDIMMESH ! DIMENSION OF THE MESH
      INTEGER, DIMENSION(1)  :: VTYPE1   ! TYPE OF THE MESH (STRUCTURED / UNSTRUCTURED)
      CHARACTER(LEN=32), DIMENSION(1)  :: VTITRE ! NAME OF THE ASSOCIATED MESH
      CHARACTER(LEN=32), DIMENSION(1)  :: VDESC ! DESCRIPTION ASSOCIATED TO THE MESH
      INTEGER :: DIMMESH ! DIMENSION OF THE MESH
      INTEGER :: TYPE1   ! TYPE OF THE MESH (STRUCTURED / UNSTRUCTURED)
      CHARACTER(LEN=32) :: TITRE ! NAME OF THE ASSOCIATED MESH
      CHARACTER(LEN=32) :: DESC ! DESCRIPTION ASSOCIATED TO THE MESH

      CHARACTER(LEN=32) :: NOMCHAMED ! NAME OF THE MED FIELD
      CHARACTER(LEN=32) :: NOMVAR2   ! MED NAME OF THE VARIABLE
C
      INTEGER         , DIMENSION(:), allocatable :: IDATAVAR
      DOUBLE PRECISION, DIMENSION(:), allocatable :: DATAVAR
      DOUBLE PRECISION, DIMENSION(:), allocatable,save :: DEF_MAP
      CHARACTER(LEN=32) :: CHA
      INTEGER           :: IDDIM
      LOGICAL           :: ISVECTOR  
      INTEGER           ::  LME
!LOCAL DECLARATION    
      INTEGER           :: NB_VAR,I
!***********************************************************************
!     IF(DEBUG) CALL PROC_BEGIN('WRITE_DATA_MED')
!***********************************************************************
      CRET  = 0 ! CODE RETOUR

         
! FALAPPI LECTURE DU NOMBRE DE MAILLAGE
      CALL EFNMAA(FILERES,NUMMESH,CRET)          
      CALL MED_CHECK_CRET(CRET,'EFNMAA')



! LECTURE DES INFOS SUR LE MAILLAGE
      ! BUG on a cluster with ifort release 11 (??)
      VTITRE = ''
!      CALL EFMAAI(FILERES,1,TITRE,DIMMESH,TYPE1,DESC,CRET)
      CALL EFMAAI(FILERES,1,VTITRE(1),VDIMMESH(1)
     * ,VTYPE1(1),VDESC(1),CRET)
!      DO I=1,NUMMESH
!      CALL EFMAAI
!     *(FILERES,I,VTITRE(I),VDIMMESH(I),VTYPE1(I),VDESC(I),CRET)
!      CALL MED_CHECK_CRET(CRET,'EFMAAI')
!      ENDDO
      ! PUISQU'IL Y A DES VALEURS SUR VECTEURS LIBRE ...
      ! ON DETERMINE LE TYPE DE VARIABLE QU'UNE SEULE FOIS ET CROISE LES
      ! DOIGTS (DANS TELEMAC2D, L'ENERGIE TURBULENTE A UN ELM DE -1000
      ! BIZARREMENT ...
      
      TITRE = VTITRE(1)
      DIMMESH = VDIMMESH(1)
      TYPE1 = VTYPE1(1)
      DESC = VDESC(1)
      
      IVAR=0
      I=1
      DO WHILE(IVAR == 0)
        IF(BVARSOR%ADR(I)%P%ELM.GT.0) IVAR=I
        I=I+1
      ENDDO
      IF(BVARSOR%ADR(IVAR)%P%ELM/10 .EQ. 1 ) THEN
        TYP_MED = MED_TRIA3 
      ELSEIF(BVARSOR%ADR(IVAR)%P%ELM/10 .EQ. 2 ) THEN
        TYP_MED = MED_QUAD4 
      ELSEIF(BVARSOR%ADR(IVAR)%P%ELM/10 .EQ. 3 ) THEN
        TYP_MED = MED_TETRA4
      ELSEIF(BVARSOR%ADR(IVAR)%P%ELM/10 .EQ. 4 ) THEN
        TYP_MED = MED_PENTA6 
      ELSE
        WRITE(LU,*)'ERROR ON ELEMENT TYPE!',BVARSOR%ADR(IVAR)%P%ELM
        CALL PLANTE(1)
        STOP
      ENDIF
      IVAR=0
      I=1


      IVAR=1
      NB_VAR = 0
      DO IVAR = 1 , NVARS
        IF (.NOT. OUTVAR(IVAR)) CYCLE
        TYP_DISC = MED_NOEUD
        LME = BVARSOR%ADR(IVAR)%P%ELM
        IF ((LME.GT.0) .and. ((LME-(LME/10)*10)==0)) 
     *                            TYP_DISC = MED_MAILLE 
 
          NB_VAR = NB_VAR+1
          NOMVAR2   = NOMVAR(IVAR)
          CALL BLANC2_(NOMVAR2)
          NOMCHAMED = NOMVAR2(1:16)//CHAR(0)
!          DATAVAR => BVARSOR%ADR(IVAR)%P%R
          NDATA   =  BVARSOR%ADR(IVAR)%P%DIM1
          call IFVECTOR_(NOMCHAMED,IDDIM,ISVECTOR)
!Dans le cas de vecteur on alloue dabord le tableau et on ecrira
! quand le tableau sera complet
          if (IDDIM == 1) allocate(DATAVAR(1:DIMMESH*NDATA))
          if (IDDIM == 1) allocate(IDATAVAR(1:DIMMESH*NDATA))
          if (BVARSOR%ADR(IVAR)%P%NAT == 1) then         !real
          if (ISVECTOR)then
            DATAVAR((IDDIM-1)*NDATA+1:(IDDIM)*NDATA)=
     *                            BVARSOR%ADR(IVAR)%P%R(1:NDATA)
            elseif (.not.ISVECTOR) then
              allocate(DATAVAR(1:NDATA))
              allocate(IDATAVAR(1:NDATA))
              DATAVAR(1:NDATA)=BVARSOR%ADR(IVAR)%P%R(1:NDATA)
            endif
          elseif (BVARSOR%ADR(IVAR)%P%NAT == 2) then    ! integer
            IF (ISVECTOR)THEN
              IDATAVAR((IDDIM-1)*NDATA+1:(IDDIM)*NDATA)=
     *                            BVARSOR%ADR(IVAR)%P%I(1:NDATA)
            ELSEIF (.not.ISVECTOR)THEN
                allocate(DATAVAR(1:NDATA))
                allocate(IDATAVAR(1:NDATA))
                IDATAVAR(1:NDATA) = BVARSOR%ADR(IVAR)%P%I(1:NDATA)
                DATAVAR(1:NDATA) = dble(IDATAVAR(1:NDATA))
            ENDIF
          endif

          if ((IDDIM==DIMMESH).or.(.not.ISVECTOR)) then                  
          CALL EFCHAE(FILERES,           ! ID FICHIER
     *                TITRE,             ! TITLE OF ASSOCIATED MESH
     *                NOMCHAMED,         ! NAME OF THE DATA FIELD
     *                DATAVAR,           ! DATA ARRAY TO WRITE
     *                MED_NO_INTERLACE,  ! IF VECTOR, STORAGE MODE
     *                NDATA,             ! NUMBER OF DATA VALUES
     *                MED_NOGAUSS,       ! NO GAUSS POINTS HERE
!     *                IVAR,             ! ID OF COMPONENT TO WRITE
     *                MED_ALL,           ! ID OF COMPONENT TO WRITE
     *                MED_NOPFL,         ! NO PROFILE
     *                MED_COMPACT,       ! COMPACT MEM STORAGE
!     *                MED_NOEUD,         ! VALUE LOCATION (NODES HERE)
     *                TYP_DISC,          ! VALUE LOCATION (P0 or P1 HERE
     *                TYP_MED,           ! GEOMETRIC ENTITY (NODE)
     *                TIMESTEP,          ! TIME STEP ( INTEGER )
     *                'S               ',! TIME UNIT
     *                TIME,              ! TIME
     *                MED_NONOR,         ! NO ORDER
     *                CRET)
          CALL MED_CHECK_CRET(CRET,'EFCHAE')
          deallocate(DATAVAR)
          deallocate(IDATAVAR)
          endif

      END DO ! LOOP OVER ENTRIES IN BVARSOR

!On rajoute la possibilite en 3D d'ecrire un champ de scalaire pour la 
!deformation du maillage
!les 3 premieres composantes correspondnant au vecteur deformation du 
!maillage (pas de deformation = (0,0,0)
!les autres composantes correspondnant aux diffrents champs ecrit dans
! le fichier med il s'agit d une surdefintion qui peut etre couteuse en 
!espace memoire suivant le nombre de variable et le type de cas de calcu
! This function is also called for the 2d mesh in telemac3d
      IF (NNAMECODE(1) == 'TELEMAC3D               '
     * .AND. dimmesh.EQ.3)THEN
          NOMVAR2   = 'MODIF FIELD'
          CALL BLANC2_(NOMVAR2)
          NOMCHAMED = NOMVAR2(1:16)//CHAR(0)
          NDATA   =  BVARSOR%ADR(1)%P%DIM1
          if (TIMESTEP==0) allocate(DEF_MAP(1:NDATA*3))
          if (TIMESTEP==0) DEF_MAP(1:2*NDATA)        = 0.0d0  
          if (TIMESTEP==0) DEF_MAP(2*NDATA+1:3*NDATA)= 
     *                                BVARSOR%ADR(1)%P%R(1:NDATA)
          allocate(DATAVAR(1:NDATA*(3+NB_VAR)))
          DATAVAR(2*NDATA+1:3*NDATA)= BVARSOR%ADR(1)%P%R(1:NDATA)-
     *            DEF_MAP(2*NDATA+1:3*NDATA)
          DATAVAR(1:2*NDATA)        = 0.0d0
          NB_VAR=0
          DO IVAR = 1, NVARS
              IF (.NOT. OUTVAR(IVAR)) CYCLE
              NB_VAR=NB_VAR+1
              DATAVAR((2+NB_VAR)*NDATA+1:(3+NB_VAR)*NDATA)= 
     *                                BVARSOR%ADR(IVAR)%P%R(1:NDATA)
          ENDDO

          CALL EFCHAE(FILERES,           ! ID FICHIER
     *                TITRE,             ! TITLE OF ASSOCIATED MESH
     *                NOMCHAMED,         ! NAME OF THE DATA FIELD
     *                DATAVAR,           ! DATA ARRAY TO WRITE
     *                MED_NO_INTERLACE,  ! IF VECTOR, STORAGE MODE
     *                NDATA,             ! NUMBER OF DATA VALUES
     *                MED_NOGAUSS,       ! NO GAUSS POINTS HERE
     *                MED_ALL,          ! ID OF COMPONENT TO WRITE
     *                MED_NOPFL,         ! NO PROFILE
     *                MED_COMPACT,       ! COMPACT MEM STORAGE
!     *                MED_NOEUD,         ! VALUE LOCATION (NODES HERE)
     *                TYP_DISC,          ! VALUE LOCATION (P0 or P1 HERE
     *                TYP_MED,           ! GEOMETRIC ENTITY (NODE)
     *                TIMESTEP,          ! TIME STEP ( INTEGER )
     *                'S               ',! TIME UNIT
     *                TIME,              ! TIME
     *                MED_NONOR,         ! NO ORDER
     *                CRET)
            CALL MED_CHECK_CRET(CRET,'EFCHAE')
            deallocate(DATAVAR)          
      ENDIF

!***********************************************************************
!     IF(DEBUG) CALL PROC_END('WRITE_DATA_MED')
!***********************************************************************
      RETURN
      END SUBROUTINE WRITE_DATA_MED
C                       ********************
                        SUBROUTINE SUITE_MED
C                       ********************
C
     *(VARSOR,CLAND,NUMDEB,
     * FILERES,STD,HIST,NHIST,NPOIN,AT,TEXTPR,VARCLA,NVARCL,
     * TROUVE,ALIRE,LISTIN,FIN,MAXVAR,NPLAN,DT,NDT)
C
C***********************************************************************
C BIEF VERSION 6.0      18/03/2009                      B DELHOM (INCKA)
C
C***********************************************************************
C
C   FONCTION  : LECTURE DES RESULTATS INSCRITS SUR UN FICHIER
C               DE RESULTATS AU FORMAT MED.
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________
C |      NOM       |MODE|                   ROLE
C |________________|____|______________________________________________
C |   VARSOR       |<-- | BLOC DES TABLEAUX CONTENANT LES VARIABLES
C |   CLAND        |<-- | BLOC DES VARIABLES CLANDESTI-NES
C |   NUMDEB       |<-->| FIN = .TRUE. NUMERO DU DERNIER ENREGISTREMENT
C |                |    | FIN = .FALSE. : NUMERO DE L'ENREGISTREMENT
C |                |    |                 QUE L'ON VEUT LIRE.
C |   FILERES      | -->| NUMERO DE CANAL DU FICHIER
C |   STD          | -->| BINAIRE DU FICHIER : STD, IBM OU I3E
C |   HIST         | -->| TABLEAU DE VALEURS MISES DANS L'ENREGISTREMENT
C |                |    | DU TEMPS.
C |   NHIST        | -->| NOMBRE DE VALEURS DANS LE TABLEAU HIST.
C |   NPOIN        | -->| NOMBRE DE POINTS DANS LE MAILLAGE
C |   AT           | -->| TEMPS
C |   TEXTPR       | -->| NOMS ET UNITES DES VARIABLES.
C |   VARCLA       | -->| TABLEAU OU L'ON RANGE LES VARIABLES
C |                |    | CLANDESTIINES.
C |   NVARCL       | -->| NOMBRE DE VARIABLES CLANDESTI-NES.
C |   TROUVE       |<-- | INDIQUE (TROUVE(K)=1) LES VARIABLES TROUVEES
C |                |    | DANS LE FICHIER.
C |                |    | DE K =  1 A 26 VARIABLES NORMALES
C |                |    | DE K = 27 A 36 VARIABLES CLANDESTI-NES.
C |   ALIRE        | -->| VARIABLES QU'IL FAUT LIRE (POUR LES AUTRES ON
C |                |    | SAUTE L'ENREGISTREMENT CORRESPONDANT)
C |                |    | LES VARIABLES CLANDESTI-NES SONT LUES
C |                |    | SYSTEMATIQUEMENT.
C |   LISTIN       | -->| SI OUI, IMPRESSION D'INFORMATIONS SUR LISTING
C |   FIN          | -->| VOIR LE TROISIEME ARGUMENT NUMDEB
C |   MAXVAR       | -->| DIMENSION DES TABLEAUX DES VARIABLES : ALIRE, ETC
C |________________|____|_______________________________________________
C MODE : -->(DONNEE NON MODIFIEE), <--(RESULTAT), <-->(DONNEE MODIFIEE)
C-----------------------------------------------------------------------
C
C
C***********************************************************************
C
      USE BIEF
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      TYPE(BIEF_OBJ), INTENT(INOUT) :: VARSOR,CLAND
      INTEGER, INTENT(IN), OPTIONAL :: NPLAN
      INTEGER, INTENT(IN)           :: NHIST,NVARCL,MAXVAR,FILERES
      INTEGER, INTENT(OUT), OPTIONAL :: NDT
      INTEGER                       :: NUMDEB,NPOIN,TROUVE(MAXVAR)
      INTEGER                       :: ALIRE(MAXVAR)        
      CHARACTER(LEN=*)              :: STD
      CHARACTER(LEN=32)             :: TEXTPR(MAXVAR),VARCLA(NVARCL)
      DOUBLE PRECISION              :: HIST(*),AT
      LOGICAL                       :: FIN,LISTIN 
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C 
      INTEGER :: CRET    ! RETURN CODE
      INTEGER :: IVAR    ! VARIABLE ID TO OUTPUT
      INTEGER :: TYPE1   ! TYPE OF THE MESH (STRUCTURED / UNSTRUCTURED)
      INTEGER :: NDATA   ! NUMBER OF DATA POINTS TO WRITE
      INTEGER :: DIMMESH ! DIMENSION OF THE MESH
      INTEGER :: TYP_MED ! NUMBER OF COMPONENTS
C
      CHARACTER(LEN=32) :: TITRE ! NAME OF THE ASSOCIATED MESH
      CHARACTER(LEN=32) :: NOMCHAMED ! NAME OF THE MED FIELD
      CHARACTER(LEN=32) :: NOMVAR2   ! MED NAME OF THE VARIABLE
C
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: DATAVAR
      INTEGER :: NTIME
C
C-----------------------------------------------------------------------
C
C     DUMMY OUTPUT ARGUMENT NEED FOR CALCUL
!      INTEGER :: LOCNAME,PROFIL,
      INTEGER           :: I,NGAUSS,NUMDT,NUMO,NMAA,TYP,NCOMP,NUMDT2
      CHARACTER(LEN=16) :: LOCNAME,PROFIL
      DOUBLE PRECISION  :: DT
      CHARACTER(LEN=32) :: CHA,CHA2
      CHARACTER(LEN=160) :: COMP,UNIT
      character(len=16)DTUNIT
      LOGICAL :: OK,LOCAL
      INTEGER :: ISFIRST,DIMVEC,ncomp2

!***********************************************************************
!     IF(DEBUG) CALL PROC_BEGIN('SUITE_MED')
!***********************************************************************

      CRET  = 0 ! CODE RETOUR
      IVAR=0
      I=1
      DO WHILE(IVAR == 0)
       IF ((VARSOR%ADR(I)%P%ELM.GT.0)) IVAR=I
       I=I+1
      ENDDO
      IF(VARSOR%ADR(IVAR)%P%ELM/10 .EQ. 1 ) THEN
        TYP_MED = MED_TRIA3
      ELSEIF ( VARSOR%ADR(IVAR)%P%ELM/10 .EQ. 2 ) THEN
        TYP_MED = MED_QUAD4  
      ELSEIF ( VARSOR%ADR(IVAR)%P%ELM/10 .EQ. 3 ) THEN
        TYP_MED = MED_TETRA4
      ELSEIF ( VARSOR%ADR(IVAR)%P%ELM/10 .EQ. 4 ) THEN
        TYP_MED = MED_PENTA6 
      ELSE
        WRITE(LU,*) 'ERROR ON ELEMENT TYPE!',VARSOR%ADR(IVAR)%P%ELM
        CALL PLANTE(1)
        STOP
      ENDIF
      IVAR=0
      I=1
      DO WHILE(IVAR == 0)
        IF (ALIRE(I)==1) IVAR=I
        I=I+1
      ENDDO
      NOMVAR2   = TEXTPR(IVAR)
      CALL BLANC2_(NOMVAR2)
      NOMCHAMED = NOMVAR2(1:16)//CHAR(0)
      CALL IFVECTOR_(NOMCHAMED,ISFIRST,OK)      
!     NOMBRE MAX DE PAS DE TEMPS     
      CALL EFNPDT(FILERES,NOMCHAMED,MED_NOEUD,TYP_MED,NTIME,CRET)
!      CALL MED_CHECK_CRET(CRET,'EFNPDT')
!     ON LIT LE TEMPS ASSOCIE AINSI QUE LE NOM DU MAILLAGE 
      CALL EFPDTI(FILERES,NOMCHAMED,MED_NOEUD,TYP_MED,NTIME,NGAUSS,
     *            NUMDT,NUMO,DTUNIT,DT,TITRE,LOCAL,NMAA,CRET) 
      CALL MED_CHECK_CRET(CRET,'EFPDTI') 
      NUMDEB = NTIME
      AT = DT
      if (NTIME>1) CALL EFPDTI(FILERES,NOMCHAMED,MED_NOEUD,TYP_MED,
     *                  NTIME-1,NGAUSS,
     *                  NUMDT2,NUMO,DTUNIT,DT,TITRE,LOCAL,NMAA,CRET) 
      DT = AT-DT
!BD_INCKA CHERCHE LES NOMS DES CHAMP STOCKES 'CHA' ET COMPARE A LA LISTE
! DE LECTURE => TROUVE = 1 ON UTILISERA CETTE VALEUR PAR LA SUITE
!PB DANS LE CAS DE VECTEUR, LA PREMIERE LECTURE NOUS RETOURNE UN NOM VIDE
! ON LE REFAIT UNE DEUXIEME FOIS DANS CE CAS LA
!YA_ Comming from the fact that comp and unit must a character length of 
! 16*ncomp and for a vector ncomp>1      
      CALL EFNCHA(FILERES,0,NCOMP,CRET)
      CALL MED_CHECK_CRET(CRET,'EFNCHA')
      TROUVE = 0
      DIMVEC = 1
      DO I=1,NCOMP
      call efncha(fileres,i,ncomp2,cret)
      CALL MED_CHECK_CRET(CRET,'EFNCHA')
      CALL EFCHAI(FILERES,I,CHA,TYP,COMP,UNIT,ncomp2,CRET)
      CALL MED_CHECK_CRET(CRET,'EFCHAI')
      DO IVAR = 1,MAXVAR
        NOMVAR2   = TEXTPR(IVAR)
        CALL BLANC2_(NOMVAR2)
        CALL IFVECTOR_(NOMVAR2,ISFIRST,OK)
        DIMVEC = MAX(DIMVEC,ISFIRST)
        IF (NOMVAR2(1:16) == CHA(1:16)) TROUVE(IVAR)=1
      ENDDO
      ENDDO
!CHARGE LE DERNIER CHAMP DU FICHIER MED DANS DATAVAR POUR LES VARIABLES TROUVEES
! DANS LE TABLEAU DE LECTURE ET DANS LE FICHIER RESULTAT MED PRECEDENT
      DO IVAR = 1, MAXVAR
        IF (TROUVE(IVAR)/=1) CYCLE
          IF (ALIRE(IVAR)==1) THEN 
          NOMVAR2   = TEXTPR(IVAR)
          CALL BLANC2_(NOMVAR2)
          NOMCHAMED = NOMVAR2(1:16)//CHAR(0)
          CALL IFVECTOR_(NOMCHAMED,ISFIRST,OK)
          NDATA   =  VARSOR%ADR(IVAR)%P%DIM1
          IF(OK) THEN
            ALLOCATE(DATAVAR(DIMVEC*NDATA))
          ELSE
            ALLOCATE(DATAVAR(NDATA))
          ENDIF
          CRET=2
          CALL EFCHAL(FILERES,           ! ID FICHIER
     *                TITRE,             ! TITLE OF ASSOCIATED MESH
     *                NOMCHAMED,         ! NAME OF THE DATA FIELD
     *                DATAVAR,           ! DATA ARRAY TO READ
     *                MED_NO_INTERLACE,  ! IF VECTOR, STORAGE MODE
     *                MED_ALL,           ! COMPOSANTE NUMBER OF DATA VALUES
!     *                MED_NOGAUSS,       ! NO GAUSS POINTS HERE
!     *                MED_NOPFL,         ! NO PROFILE
     *                locname,           ! NO GAUSS POINTS HERE
     *                profil,            ! NO PROFILE
     *                MED_COMPACT,       ! COMPACT MEM STORAGE
     *                MED_NOEUD,         ! VALUE LOCATION (NODES HERE)
     *                TYP_MED,           ! GEOMETRIC ENTITY (NODE)
     *                NUMDT,             ! TIME (IN) TO READ
     *                MED_NONOR,         ! NO ORDER
     *                CRET)
            CALL MED_CHECK_CRET(CRET,'EFCHAL')
            NDATA   =  VARSOR%ADR(IVAR)%P%DIM1
            IF (.NOT.OK) VARSOR%ADR(IVAR)%P%R = DATAVAR
            IF (OK) VARSOR%ADR(IVAR)%P%R(1:NDATA) =
     *                     DATAVAR((ISFIRST-1)*NDATA+1:(ISFIRST)*NDATA)
            DEALLOCATE(DATAVAR)
            ELSE
            IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,75) TEXTPR(IVAR)
            IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,76) TEXTPR(IVAR)
75          FORMAT(/,1X,'LA VARIABLE : ',A32,/,1X,
     *                'EST DANS LE FICHIER MAIS ELLE N''EST PAS LUE')
76          FORMAT(/,1X,'VARIABLE : ',A32,/,1X,
     *                'IS IN THE FILE BUT WILL NOT BE READ')
            ENDIF
      END DO ! LOOP OVER ENTRIES IN VARSOR
C
C-----------------------------------------------------------------------
C
C  IMPRESSIONS :
C
      IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,300) TITRE
      IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,301) TITRE
300   FORMAT(1X,//,1X,'TITRE DU CAS PRECEDENT: ',A72,/)
301   FORMAT(1X,//,1X,'TITLE OF PREVIOUS COMPUTATION: ',A72,/)
C
      DO IVAR=1,MAXVAR
        IF ((TROUVE(IVAR) ==1).and.(ALIRE(IVAR) == 1)) THEN
        IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,11)
     *    TEXTPR(IVAR)(1:16),TEXTPR(IVAR)(17:32)
        IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,111)
     *    TEXTPR(IVAR)(1:16),TEXTPR(IVAR)(17:32)
        ENDIF
11      FORMAT(1X,'NOM: ' ,A16,'  UNITE: ',A16)
111     FORMAT(1X,'NAME: ',A16,'  UNIT: ' ,A16)
      ENDDO

      IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,130) NUMDEB
      IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,131) NUMDEB
130   FORMAT(/,1X,'SUITE_MED : LECTURE A L''ENREGISTREMENT ',1I5)
131   FORMAT(/,1X,'SUITE_MED : READ OF RECORD ',1I5)

      IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,140) AT
      IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,141) AT
140   FORMAT(//,1X,'TEMPS DE L''ENREGISTREMENT : ',G16.7,' S')
141   FORMAT(//,1X,'TIME OF RECORD: ',G16.7,' S')

      IF(PRESENT(NDT)) NDT=NUMDT
           
!***********************************************************************
!     IF(DEBUG) CALL PROC_END('SUITE_MED')
!***********************************************************************
      RETURN
      END SUBROUTINE SUITE_MED
C                       ******************
                        SUBROUTINE BLANC2_
C                       ******************
C
     *(CHAR)
C
C***********************************************************************
C BIEF VERSION 6.0           29/04/08    J HOLLEVILLE (INCKA)   47 80 79
C***********************************************************************
C
C FONCTION :
C
C     WRITE ' ' TO '_'
C
C***********************************************************************
C
      INTEGER :: J
      CHARACTER(LEN=32), INTENT(INOUT) :: CHAR
C
C-----------------------------------------------------------------------
C
      DO J = 1,32
        IF (CHAR(J:J) .EQ. ' ') THEN
          CHAR(J:J) = '_'
        ENDIF
      ENDDO
C
C-----------------------------------------------------------------------
C
      RETURN
      END SUBROUTINE BLANC2_
C                       ******************
                        SUBROUTINE IFVECTOR_
C                       ******************
C
     *(CHAR,ISFIRST,OK)
C
C***********************************************************************
C BIEF VERSION 5.9           18/03/2009 B DELHOM (INCKA)
C***********************************************************************
C
C FONCTION :
C
C     FIND '_U_' '_V_' '_W_' '_X_' '_Y_' '_Z_' in name field of scalar 
C     or vector
C     return : OK = TRUE, it's a vector
C     return : ISFIRST = direction of vector 
C     
C
C***********************************************************************
C
      INTEGER :: J
      CHARACTER(LEN=32), INTENT(INOUT) :: CHAR
      INTEGER, INTENT(OUT)             :: ISFIRST
      LOGICAL, INTENT(OUT)             :: OK
C
C-----------------------------------------------------------------------
C
      OK = .FALSE.
      ISFIRST = 0
       
      IF (CHAR(1:6)/='COTE_Z') then
      DO J = 2,31
        IF (CHAR(J-1:J+1) .EQ. '_U_') THEN
          CHAR(J:J) = '*'
          ISFIRST = 1
          OK = .TRUE.
        ELSEIF (CHAR(J-1:J+1) .EQ. '_V_') THEN
          CHAR(J:J) = '*'
          ISFIRST = 2
          OK = .TRUE.
        ELSEIF (CHAR(J-1:J+1) .EQ. '_W_') THEN
          CHAR(J:J) = '*'
          ISFIRST = 3
          OK = .TRUE.
        ELSEIF (CHAR(J-1:J+1) .EQ. '_X_') THEN
          CHAR(J:J) = '*'
          ISFIRST = 1
          OK = .TRUE.
        ELSEIF (CHAR(J-1:J+1) .EQ. '_Y_') THEN
          CHAR(J:J) = '*'
          ISFIRST = 2
          OK = .TRUE.
        ELSEIF (CHAR(J-1:J+1) .EQ. '_Z_') THEN
          CHAR(J:J) = '*'
          ISFIRST = 3
          OK = .TRUE.
         ELSEIF (CHAR(J-1:J+1) .EQ. 'QX_') THEN
           CHAR(J-1:J) = 'Q*'
           ISFIRST = 1
           OK = .TRUE.
         ELSEIF (CHAR(J-1:J+1) .EQ. 'QY_') THEN
           CHAR(J-1:J) = 'Q*'
           ISFIRST = 2
           OK = .TRUE.
         ELSEIF (CHAR(J-1:J+1) .EQ. 'QZ_') THEN
           CHAR(J-1:J) = 'Q*'
           ISFIRST = 3
           OK = .TRUE.
         ELSEIF (CHAR(J-1:J+1) .EQ. 'U0_') THEN
           CHAR(J-1:J) = '*0'
           ISFIRST = 1
           OK = .TRUE.
         ELSEIF (CHAR(J-1:J+1) .EQ. 'V0_') THEN
           CHAR(J-1:J) = '*0'
           ISFIRST = 2
           OK = .TRUE.
         ELSEIF (CHAR(J-1:J+1) .EQ. 'W0_') THEN
           CHAR(J-1:J) = '*0'
           ISFIRST = 3
           OK = .TRUE.
        ENDIF
      ENDDO
      endif
C
      RETURN
      END SUBROUTINE IFVECTOR_

C
C***********************************************************************
C
C
C
C***********************************************************************
C

      END MODULE M_MED
